<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>2-Person Video/Sound Communicator (WebRTC)</title>

  
<style>
body{font-family:system-ui;margin:16px}
h1{font-size:20px}
.row{display:flex;gap:12px;flex-wrap:wrap}
.card{border:1px solid #ddd;border-radius:12px;padding:12px;flex:1 1 320px}
.videos{display:grid;grid-template-columns:1fr 1fr;gap:12px}
video{width:100%;background:#000;border-radius:12px;aspect-ratio:16/9}
button{padding:10px 12px;border-radius:10px;border:1px solid #ccc;background:#f7f7f7;cursor:pointer}
button:disabled{opacity:.6;cursor:not-allowed}
input{padding:10px 12px;border-radius:10px;border:1px solid #ccc;width:100%}
.status{font-size:13px;margin-top:8px}
.small{font-size:12px;color:#555;margin-top:6px}
#errorBox{display:none;margin:12px 0;padding:10px;border:1px solid #f3b5b5;background:#fff5f5;color:#7a1b1b;border-radius:12px;white-space:pre-wrap}

/* Login overlay */
#loginOverlay{
  position:fixed; inset:0; z-index:9999;
  background:rgba(0,0,0,.55);
  display:flex; align-items:center; justify-content:center;
}
#loginCard{
  width:min(520px,calc(100% - 24px));
  background:#fff; border-radius:14px;
  padding:16px;
  box-shadow:0 10px 30px rgba(0,0,0,.35);
}
#loginRow{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
#logoutBtn{float:right}
#app.locked{filter:blur(2px);opacity:.35;pointer-events:none;user-select:none}

/* Diagnostics */
#diagCard{margin-top:12px}
#logBox{
  width:100%;
  min-height:120px;
  max-height:280px;
  resize:vertical;
  font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;
  font-size:12px;
  padding:10px;
  border-radius:12px;
  border:1px solid #ddd;
  background:#fafafa;
  white-space:pre;
  overflow:auto;
}
.diagRow{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
</style>
</head>

<body>
<h1>2-Person Video/Sound Communicator (WebRTC)</h1>
<div id="errorBox"></div>

<!-- LOGIN OVERLAY -->
<div id="loginOverlay">
  <div id="loginCard">
    <button id="logoutBtn" style="display:none;">Logout</button>
    <h2 style="margin:0 0 8px;font-size:18px;">Sign in required</h2>
    <div class="small">Only approved users can access this communicator.</div>

    <label class="small">Email</label>
    <input id="emailInput" type="email" placeholder="you@example.com" autocomplete="username" />

    <label class="small">Password</label>
    <input id="passInput" type="password" placeholder="••••••••" autocomplete="current-password" />

    <div id="loginRow">
      <button id="loginBtn">Login</button>
    </div>

    <div id="loginStatus" class="status">Please sign in.</div>
    <div class="small">After login, click/tap once to enable camera/mic (browser permission rule).</div>
  </div>
</div>

<div id="app" class="locked">
  <div class="videos">
    <div class="card">
      <b>Person A (You)</b>
      <video id="localVideo" autoplay muted playsinline></video>
    </div>
    <div class="card">
      <b>Person B (Other)</b>
      <video id="remoteVideo" autoplay playsinline></video>
    </div>
  </div>

  <div class="row">
    <div class="card">
      <b>Step 1</b><br/>
      <button id="startBtn" disabled>Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <div class="status" id="mediaStatus">Not started.</div>
    </div>

    <div class="card">
      <b>Step 2</b><br/>
      <button id="createBtn" disabled>Create Room</button>
      <button id="joinBtn" disabled>Join Room</button>
      <input id="roomId" placeholder="Room ID"/>
      <button id="copyLinkBtn" disabled>Copy Invite</button>
      <div class="status" id="callStatus">No room yet.</div>
      <div class="small">Tip: invite looks like …/webrtc.html#ROOM_ID</div>
    </div>
  </div>

  <div class="card" id="diagCard">
    <b>Diagnostics</b>
    <div class="small">If it gets stuck, click <b>Copy log</b> and paste it here.</div>
    <div class="diagRow">
      <button id="copyLogBtn">Copy log</button>
      <button id="clearLogBtn">Clear log</button>
    </div>
    <textarea id="logBox" readonly></textarea>
  </div>
</div>

<script type="module">
/* ---------- ERROR HANDLING ---------- */
const errorBox=document.getElementById("errorBox");
function showError(e){
  errorBox.style.display="block";
  errorBox.textContent=String(e?.stack||e);
  console.error(e);
}
function hideErrorBox(){
  errorBox.style.display = "none";
  errorBox.textContent = "";
}
window.addEventListener("error",e=>showError(e.error||e.message||e));
window.addEventListener("unhandledrejection",e=>showError(e.reason||e));

/* ---------- DIAGNOSTICS ---------- */
const logBox = document.getElementById("logBox");
const copyLogBtn = document.getElementById("copyLogBtn");
const clearLogBtn = document.getElementById("clearLogBtn");

const LOG_MAX = 400;
const logs = [];
function ts(){
  const d = new Date();
  const pad = (n, w=2)=>String(n).padStart(w,"0");
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}.${pad(d.getMilliseconds(),3)}`;
}
function log(msg, obj){
  const line = `[${ts()}] ${msg}${obj!==undefined ? " " + safeJson(obj) : ""}`;
  logs.push(line);
  if (logs.length > LOG_MAX) logs.shift();
  logBox.value = logs.join("\n");
  logBox.scrollTop = logBox.scrollHeight;
  console.log(line);
}
function safeJson(x){
  try { return JSON.stringify(x); } catch { return String(x); }
}
clearLogBtn.onclick = ()=>{ logs.length=0; logBox.value=""; };
copyLogBtn.onclick = async ()=>{
  const text = logs.join("\n");
  if (navigator.clipboard && window.isSecureContext) {
    try { await navigator.clipboard.writeText(text); log("LOG: copied to clipboard"); return; } catch {}
  }
  window.prompt("Copy log:", text);
};

log("Page loaded", { href: location.href });

/* ---------- Firebase imports ---------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
import {
  getFirestore, doc, collection, addDoc, setDoc, getDoc, updateDoc,
  onSnapshot, getDocs, writeBatch
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";
import {
  getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";

/* ---------- FIREBASE ---------- */
const app=initializeApp({
  apiKey:"AIzaSyAg6TXwgejbPAyuEPEBqW9eHaZyLV4Wq98",
  authDomain:"easosunov-webrtc.firebaseapp.com",
  projectId:"easosunov-webrtc",
  storageBucket:"easosunov-webrtc.firebasestorage.app",
  messagingSenderId:"100169991412",
  appId:"1:100169991412:web:27ef6820f9a59add6b4aa1"
});
const db=getFirestore(app);
const auth=getAuth(app);

/* ---------- AUTH GATE ---------- */
let isAuthed=false;

/* ---------- LOGIN UI ---------- */
const loginOverlay=document.getElementById("loginOverlay");
const loginBtn=document.getElementById("loginBtn");
const logoutBtn=document.getElementById("logoutBtn");
const loginStatus=document.getElementById("loginStatus");
const emailInput=document.getElementById("emailInput");
const passInput=document.getElementById("passInput");
const appRoot=document.getElementById("app");

emailInput.addEventListener("input", hideErrorBox);
passInput.addEventListener("input", hideErrorBox);

loginBtn.onclick = async () => {
  loginStatus.textContent = "Signing in…";
  hideErrorBox();
  log("AUTH: login button clicked", { email: emailInput.value.trim() });

  try {
    await signInWithEmailAndPassword(auth, emailInput.value.trim(), passInput.value);
  } catch (e) {
    const code = String(e?.code || "");
    const msg =
      code === "auth/invalid-credential" ? "Wrong email or password." :
      code === "auth/user-not-found" ? "Wrong email or password." :
      code === "auth/wrong-password" ? "Wrong email or password." :
      code === "auth/invalid-email" ? "Invalid email address." :
      code === "auth/missing-password" ? "Please enter your password." :
      code === "auth/too-many-requests" ? "Too many attempts. Try again later." :
      "Login failed. Please try again.";
    loginStatus.textContent = msg;
    log("AUTH: login failed", { code, message: String(e?.message||e) });

    const expected = new Set([
      "auth/invalid-credential","auth/user-not-found","auth/wrong-password",
      "auth/invalid-email","auth/missing-password","auth/too-many-requests"
    ]);
    if (!expected.has(code)) showError(e);
  }
};

logoutBtn.onclick=async()=>{
  try{ await signOut(auth); log("AUTH: signed out"); }
  catch(e){ showError(e); }
};

/* ---------- UI ---------- */
const localVideo=document.getElementById("localVideo");
const remoteVideo=document.getElementById("remoteVideo");
const startBtn=document.getElementById("startBtn");
const stopBtn=document.getElementById("stopBtn");
const createBtn=document.getElementById("createBtn");
const joinBtn=document.getElementById("joinBtn");
const copyLinkBtn=document.getElementById("copyLinkBtn");
const roomIdInput=document.getElementById("roomId");
const mediaStatus=document.getElementById("mediaStatus");
const callStatus=document.getElementById("callStatus");
const setStatus=(el,msg)=>{ el.textContent=msg; log(`STATUS(${el.id}): ${msg}`); };

/* ---------- STATE ---------- */
let localStream=null, pc=null;
let startingPromise=null;

let unsubRoomA=null, unsubCalleeA=null;
let unsubRoomB=null, unsubCallerB=null;

let lastAnsweredSessionB=null;
let lastSeenJoinRequestA=0;
let bRetryTimer=null;

let createAttemptA = 0;
let joinAttemptB = 0;

/* ✅ Auto-join control */
const hashOnLoad = (location.hash.length > 1);
let autoJoinWanted = hashOnLoad;
let autoJoinDone = false;

if (hashOnLoad) {
  roomIdInput.value = location.hash.slice(1);
  setStatus(callStatus, "Invite detected. Click/tap once to enable camera/mic and auto-join.");
  log("Room ID from URL hash", { roomId: roomIdInput.value });
}

/* ---------- WEBRTC ---------- */
const rtcConfig={iceServers:[{urls:"stun:stun.l.google.com:19302"}]};

function closePeer(){
  if(pc){
    log("Closing RTCPeerConnection");
    pc.onicecandidate=null;
    pc.ontrack=null;
    pc.onconnectionstatechange=null;
    pc.oniceconnectionstatechange=null;
    pc.onsignalingstatechange=null;
    pc.onicegatheringstatechange=null;
    pc.close();
    pc=null;
  }
  remoteVideo.srcObject=null;
}

function ensurePeer(){
  closePeer();
  pc=new RTCPeerConnection(rtcConfig);
  log("Created RTCPeerConnection");

  const rs=new MediaStream();
  remoteVideo.srcObject=rs;

  pc.ontrack=e=>{
    log("ontrack", { tracks: e.streams?.[0]?.getTracks?.().map(t=>t.kind) || [] });
    e.streams[0].getTracks().forEach(t=>rs.addTrack(t));
  };
  pc.onconnectionstatechange=()=>log("pc.connectionState", { state: pc?.connectionState });
  pc.oniceconnectionstatechange=()=>log("pc.iceConnectionState", { state: pc?.iceConnectionState });
  pc.onsignalingstatechange=()=>log("pc.signalingState", { state: pc?.signalingState });
  pc.onicegatheringstatechange=()=>log("pc.iceGatheringState", { state: pc?.iceGatheringState });

  if(!localStream) throw new Error("Local media not started.");
  localStream.getTracks().forEach(t=>pc.addTrack(t,localStream));
}

/* ---------- HELPERS ---------- */
async function clearSub(col){
  const s=await getDocs(col);
  if(s.empty) return;
  const b=writeBatch(db);
  s.forEach(d=>b.delete(d.ref));
  await b.commit();
  log("Cleared subcollection", { path: col.path, docs: s.size });
}
function requireAuth(){
  if(!isAuthed) throw new Error("Not signed in. Please login first.");
}
function clearBRetry(){
  if(bRetryTimer){ clearTimeout(bRetryTimer); bRetryTimer=null; }
}

function withTimeout(promise, ms, label){
  return Promise.race([
    promise,
    new Promise((_,rej)=>setTimeout(()=>rej(new Error(`Timeout after ${ms}ms: ${label}`)), ms))
  ]);
}

/* ---------- MEDIA ---------- */
async function startMedia(){
  requireAuth();
  if(localStream) return;
  if(startingPromise) return startingPromise;

  startingPromise = (async () => {
    setStatus(mediaStatus, "Requesting camera/mic…");
    log("getUserMedia() starting");

    // if this hangs, you’ll see it in the log (no further lines)
    localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });

    log("getUserMedia() success", {
      tracks: localStream.getTracks().map(t=>({kind:t.kind, enabled:t.enabled, readyState:t.readyState}))
    });

    localVideo.srcObject = localStream;

    startBtn.disabled = true;
    stopBtn.disabled = false;
    createBtn.disabled = false;
    joinBtn.disabled = false;

    setStatus(mediaStatus, "Camera/mic started.");
  })();

  try { await startingPromise; }
  finally { startingPromise = null; }

  await maybeAutoJoin();
}

async function maybeAutoJoin(){
  log("maybeAutoJoin()", { autoJoinWanted, autoJoinDone, isAuthed, hasStream: !!localStream, roomId: roomIdInput.value.trim() });

  if(!autoJoinWanted) return;
  if(autoJoinDone) return;
  if(!isAuthed) return;
  if(!localStream) return;
  if(!roomIdInput.value.trim()) return;

  autoJoinDone = true;
  setStatus(callStatus, "Auto-joining room…");

  try{
    await joinRoom({ fromAutoJoin:true });
  }catch(e){
    autoJoinDone = false;
    setStatus(callStatus, `Auto-join failed: ${e.message || e}`);
    log("Auto-join failed", { message: String(e?.message||e) });
  }
}

function stopAll(){
  if(unsubRoomA){unsubRoomA();unsubRoomA=null}
  if(unsubCalleeA){unsubCalleeA();unsubCalleeA=null}
  if(unsubRoomB){unsubRoomB();unsubRoomB=null}
  if(unsubCallerB){unsubCallerB();unsubCallerB=null}

  clearBRetry();
  closePeer();

  if(localStream){
    localStream.getTracks().forEach(t=>t.stop());
    localStream=null;
  }
  localVideo.srcObject=null;

  startBtn.disabled=!isAuthed;
  stopBtn.disabled=true;
  createBtn.disabled=true;
  joinBtn.disabled=true;

  setStatus(mediaStatus,"Not started.");
  setStatus(callStatus,"No room yet.");

  lastAnsweredSessionB=null;
  copyLinkBtn.disabled = !isAuthed || !roomIdInput.value.trim();
  autoJoinDone = false;
}

/* ---------- ROOM A ---------- */
async function createRoom(){
  requireAuth();
  await startMedia();

  autoJoinWanted = false;
  autoJoinDone = true;

  const myAttempt = ++createAttemptA;
  log("A:createRoom() begin", { myAttempt });

  if(unsubRoomA) unsubRoomA();
  if(unsubCalleeA) unsubCalleeA();

  const roomRef=roomIdInput.value.trim()
    ? doc(db,"rooms",roomIdInput.value.trim())
    : doc(collection(db,"rooms"));

  roomIdInput.value=roomRef.id;
  location.hash=roomRef.id;
  copyLinkBtn.disabled = false;

  log("A: roomRef", { id: roomRef.id, path: roomRef.path });

  const caller=collection(roomRef,"callerCandidates");
  const callee=collection(roomRef,"calleeCandidates");

  const snap = await withTimeout(getDoc(roomRef), 6000, "getDoc(roomRef) A");
  const prev = snap.exists() ? (snap.data().session || 0) : 0;
  const session = Number(prev) + 1;

  log("A: session bump", { prev, session });

  if(myAttempt !== createAttemptA) return;

  await withTimeout(clearSub(caller), 8000, "clearSub(caller)");
  await withTimeout(clearSub(callee), 8000, "clearSub(callee)");
  if(myAttempt !== createAttemptA) return;

  ensurePeer();

  pc.onicecandidate=e=>{
    if(e.candidate){
      addDoc(caller,{ session, ...e.candidate.toJSON() }).catch(err=>log("A: addDoc callerCandidate failed", { err: String(err) }));
    }
  };

  const offer=await pc.createOffer();
  await pc.setLocalDescription(offer);

  await withTimeout(setDoc(roomRef,{
    session,
    offer:{type:offer.type,sdp:offer.sdp},
    answer:null,
    updatedAt:Date.now()
  },{merge:true}), 8000, "setDoc(roomRef offer)");

  setStatus(callStatus,`Room active (session ${session}). Click 'Copy Invite' and send it to Person B.`);

  unsubRoomA = onSnapshot(roomRef, async (s)=>{
    if(myAttempt !== createAttemptA) return;
    const d=s.data();
    log("A:onSnapshot(room)", { session: d?.session, hasOffer: !!d?.offer, hasAnswer: !!d?.answer, joinRequest: d?.joinRequest });

    if(!d) return;

    if(d.joinRequest && d.joinRequest > lastSeenJoinRequestA){
      lastSeenJoinRequestA = d.joinRequest;
      setStatus(callStatus,"Join request received — restarting session…");
      setTimeout(()=>createRoom().catch(()=>{}),150);
      return;
    }

    if(d.answer && d.session === session && pc && pc.signalingState==="have-local-offer" && !pc.currentRemoteDescription){
      try{
        await pc.setRemoteDescription(d.answer);
        setStatus(callStatus,`Connected (session ${session}).`);
      }catch(e){
        showError(e);
        setStatus(callStatus,"Answer failed — restarting session…");
        setTimeout(()=>createRoom().catch(()=>{}),200);
      }
    }
  });

  unsubCalleeA = onSnapshot(callee,(s)=>{
    if(myAttempt !== createAttemptA) return;
    s.docChanges().forEach(ch=>{
      if(ch.type!=="added" || !pc) return;
      const c = ch.doc.data();
      if(c.session !== session) return;
      try{ pc.addIceCandidate(c); }catch{}
    });
  });
}

/* ---------- ROOM B ---------- */
async function joinRoom({ fromAutoJoin=false } = {}){
  requireAuth();
  await startMedia();

  const myAttempt = ++joinAttemptB;
  log("B:joinRoom() begin", { myAttempt, fromAutoJoin });

  if(unsubRoomB) unsubRoomB();
  if(unsubCallerB) unsubCallerB();
  clearBRetry();

  const roomId=roomIdInput.value.trim();
  if(!roomId) throw new Error("Room ID is empty.");

  const roomRef=doc(db,"rooms",roomId);

  const snap=await withTimeout(getDoc(roomRef), 6000, "getDoc(roomRef) B");
  log("B: getDoc(roomRef) done", { exists: snap.exists() });

  if(!snap.exists()){
    throw new Error("Room not found (Person A must click Create Room, or invite is wrong).");
  }

  await withTimeout(setDoc(roomRef,{joinRequest:Date.now()},{merge:true}), 6000, "setDoc(joinRequest)");
  setStatus(callStatus,"Connecting… (requested fresh offer)");

  unsubRoomB = onSnapshot(roomRef, async (s)=>{
    if(myAttempt !== joinAttemptB) return;
    const d=s.data();
    log("B:onSnapshot(room)", { session: d?.session, hasOffer: !!d?.offer, hasAnswer: !!d?.answer });

    if(!d?.offer || !d.session) return;
    if(lastAnsweredSessionB === d.session) return;

    const session = d.session;
    lastAnsweredSessionB = session;

    try{
      ensurePeer();

      const caller=collection(roomRef,"callerCandidates");
      const callee=collection(roomRef,"calleeCandidates");

      await withTimeout(clearSub(callee), 8000, "clearSub(calleeCandidates) B");

      pc.onicecandidate=e=>{
        if(e.candidate){
          addDoc(callee,{ session, ...e.candidate.toJSON() }).catch(err=>log("B: addDoc calleeCandidate failed", { err: String(err) }));
        }
      };

      await pc.setRemoteDescription(d.offer);
      const ans=await pc.createAnswer();
      await pc.setLocalDescription(ans);

      await withTimeout(updateDoc(roomRef,{answer:ans,session,answeredAt:Date.now()}), 8000, "updateDoc(answer) B");

      setStatus(callStatus,`Joined room. Connecting… (session ${session})`);

      if(unsubCallerB) { unsubCallerB(); unsubCallerB=null; }
      unsubCallerB = onSnapshot(caller,(ss)=>{
        if(myAttempt !== joinAttemptB) return;
        ss.docChanges().forEach(ch=>{
          if(ch.type!=="added" || !pc) return;
          const c = ch.doc.data();
          if(c.session !== session) return;
          try{ pc.addIceCandidate(c); }catch{}
        });
      });

      clearBRetry();
      bRetryTimer = setTimeout(async ()=>{
        if(myAttempt !== joinAttemptB) return;
        if(!pc) return;
        if(pc.connectionState === "connected") return;

        setStatus(callStatus,"Still connecting… retrying (requesting new offer)…");
        try{
          lastAnsweredSessionB = null;
          await setDoc(roomRef,{joinRequest:Date.now()},{merge:true});
        }catch(e){ showError(e); }
      }, 10000);

    }catch(e){
      lastAnsweredSessionB = null;
      showError(e);
      setStatus(callStatus,"Join failed — requesting new offer…");
      try{
        await setDoc(roomRef,{joinRequest:Date.now()},{merge:true});
      }catch(err){ showError(err); }
    }
  });
}

/* ---------- AUTH STATE ---------- */
onAuthStateChanged(auth,(user)=>{
  isAuthed=!!user;
  log("AUTH: onAuthStateChanged", { isAuthed });

  if(user){
    loginOverlay.style.display="none";
    appRoot.classList.remove("locked");
    logoutBtn.style.display="inline-block";
    loginStatus.textContent="Signed in.";

    startBtn.disabled=false;
    stopBtn.disabled=false; // allow user to reset if needed
    createBtn.disabled=false;
    joinBtn.disabled=false;

    copyLinkBtn.disabled = !roomIdInput.value.trim();

    setStatus(mediaStatus,"Ready. Click Start (or tap page) to enable camera/mic.");

    // first user gesture starts media; auto-join happens AFTER media starts
    const once = ()=> startMedia().catch(err=>{ log("startMedia() failed", { err: String(err?.message||err) }); showError(err); });
    ["click","keydown","touchstart"].forEach(ev=>{
      window.addEventListener(ev, once, { once:true });
    });

  }else{
    loginOverlay.style.display="flex";
    appRoot.classList.add("locked");
    logoutBtn.style.display="none";
    stopAll();
  }
});

/* ---------- Robust copy with fallback ---------- */
async function copyTextRobust(text){
  if (navigator.clipboard && window.isSecureContext) {
    try { await navigator.clipboard.writeText(text); return true; } catch {}
  }
  window.prompt("Copy:", text);
  return false;
}

/* ---------- UI ---------- */
startBtn.onclick=()=>startMedia().catch(showError);
stopBtn.onclick=()=>stopAll();
createBtn.onclick=()=>createRoom().catch(showError);
joinBtn.onclick=()=>joinRoom().catch(showError);

copyLinkBtn.onclick = async () => {
  const roomId = roomIdInput.value.trim();
  if (!roomId) return;
  const invite = `${location.origin}${location.pathname}#${roomId}`;
  const ok = await copyTextRobust(invite);
  setStatus(callStatus, ok ? "Invite copied." : "Clipboard blocked — link shown for manual copy.");
};

roomIdInput.addEventListener("input", () => {
  copyLinkBtn.disabled = !isAuthed || !roomIdInput.value.trim();
});

window.addEventListener("beforeunload", ()=>{ try{ closePeer(); }catch{} });
</script>
</body>
</html>
