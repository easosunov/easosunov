<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import {
    getFirestore, doc, collection, addDoc, setDoc, getDoc, updateDoc,
    onSnapshot, getDocs, writeBatch
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyAg6TXwgejbPAyuEPEBqW9eHaZyLV4Wq98",
    authDomain: "easosunov-webrtc.firebaseapp.com",
    projectId: "easosunov-webrtc",
    storageBucket: "easosunov-webrtc.firebasestorage.app",
    messagingSenderId: "100169991412",
    appId: "1:100169991412:web:27ef6820f9a59add6b4aa1"
  };

  // ---- UI ----
  const localVideo = document.getElementById("localVideo");
  const remoteVideo = document.getElementById("remoteVideo");
  const startBtn = document.getElementById("startBtn");
  const stopBtn = document.getElementById("stopBtn");
  const createBtn = document.getElementById("createBtn");
  const joinBtn = document.getElementById("joinBtn");
  const copyLinkBtn = document.getElementById("copyLinkBtn");
  const roomIdInput = document.getElementById("roomId");
  const mediaStatus = document.getElementById("mediaStatus");
  const callStatus = document.getElementById("callStatus");

  // ---- Firestore ----
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // Load roomId from URL hash if present
  if (location.hash && location.hash.length > 1) {
    roomIdInput.value = location.hash.substring(1);
  }

  function setStatus(el, msg) { el.textContent = msg; }

  // ---- WebRTC ----
  let localStream = null;
  let pc = null;

  const rtcConfig = {
    iceServers: [
      { urls: ["stun:stun.l.google.com:19302", "stun:stun1.l.google.com:19302"] }
      // Add TURN here if you want (keep STUN too)
    ]
  };

  function closePeer() {
    if (pc) {
      pc.onicecandidate = null;
      pc.ontrack = null;
      pc.onconnectionstatechange = null;
      pc.close();
      pc = null;
    }
    remoteVideo.srcObject = null;
  }

  function ensurePeerConnection() {
    closePeer();
    pc = new RTCPeerConnection(rtcConfig);

    // Remote stream
    const remoteStream = new MediaStream();
    remoteVideo.srcObject = remoteStream;

    pc.ontrack = (event) => {
      event.streams[0].getTracks().forEach(t => remoteStream.addTrack(t));
      remoteVideo.muted = false;
      remoteVideo.play().catch(() => {});
    };

    // Local tracks
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
  }

  // ---- Candidate cleanup helpers (MUST be OUTSIDE ensurePeerConnection) ----
  async function clearSubcollection(colRef) {
    const snap = await getDocs(colRef);
    if (snap.empty) return;
    const batch = writeBatch(db);
    snap.forEach(d => batch.delete(d.ref));
    await batch.commit();
  }

  async function clearRoomCandidates(roomRef) {
    await clearSubcollection(collection(roomRef, "callerCandidates"));
    await clearSubcollection(collection(roomRef, "calleeCandidates"));
  }

  async function startMedia() {
    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    localVideo.srcObject = localStream;

    setStatus(mediaStatus, "Camera/mic started.");
    startBtn.disabled = true;
    stopBtn.disabled = false;
    createBtn.disabled = false;
    joinBtn.disabled = false;
    copyLinkBtn.disabled = !roomIdInput.value.trim();
  }

  async function stopMedia() {
    closePeer();
    if (localStream) {
      localStream.getTracks().forEach(t => t.stop());
      localStream = null;
    }
    localVideo.srcObject = null;

    setStatus(mediaStatus, "Stopped.");
    setStatus(callStatus, "Call ended.");
    startBtn.disabled = false;
    stopBtn.disabled = true;
    createBtn.disabled = true;
    joinBtn.disabled = true;
    copyLinkBtn.disabled = true;
  }

  // =========================
  // Person A: Create/Restart room session
  // =========================
  async function createRoom() {
    if (!localStream) throw new Error("Start media first.");

    // Use existing roomId if present; otherwise create a new one
    let roomRef;
    const existingId = roomIdInput.value.trim();

    if (existingId) {
      roomRef = doc(db, "rooms", existingId);
    } else {
      roomRef = doc(collection(db, "rooms"));
      roomIdInput.value = roomRef.id;
      location.hash = roomRef.id;
    }

    ensurePeerConnection();

    // Clear old ICE candidates so we don't accumulate junk across sessions
    await clearRoomCandidates(roomRef);

    // Bump session counter (or initialize)
    const roomSnap = await getDoc(roomRef);
    const prevSession = roomSnap.exists() ? (roomSnap.data().session || 0) : 0;
    const session = prevSession + 1;

    const callerCandidates = collection(roomRef, "callerCandidates");
    const calleeCandidates = collection(roomRef, "calleeCandidates");

    pc.onicecandidate = async (event) => {
      if (event.candidate) await addDoc(callerCandidates, event.candidate.toJSON());
    };

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    await setDoc(roomRef, {
      session,
      offer: { type: offer.type, sdp: offer.sdp },
      answer: null,
      updatedAt: Date.now()
    }, { merge: true });

    setStatus(callStatus, `Room active. Session ${session}. Room ID: ${roomRef.id}`);
    copyLinkBtn.disabled = false;

    // Listen for answer changes — ONLY accept when session matches
    onSnapshot(roomRef, async (snapshot) => {
      const data = snapshot.data();
      if (!data?.answer || data.session !== session) return;

      const incomingSdp = data.answer.sdp;
      const currentSdp = pc.currentRemoteDescription?.sdp;

      if (incomingSdp && incomingSdp !== currentSdp) {
        await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
        setStatus(callStatus, `Connected (session ${session}).`);
      }
    });

    // Listen for callee ICE candidates
    onSnapshot(calleeCandidates, (snapshot) => {
      snapshot.docChanges().forEach(async (change) => {
        if (change.type === "added" && pc) {
          await pc.addIceCandidate(new RTCIceCandidate(change.doc.data()));
        }
      });
    });

    // Optional: if B drops, A restarts session automatically
    pc.onconnectionstatechange = () => {
      if (pc.connectionState === "failed" || pc.connectionState === "disconnected") {
        setStatus(callStatus, "Connection lost — restarting session…");
        setTimeout(() => createRoom().catch(() => {}), 1200);
      }
    };
  }

  // =========================
  // Person B: Follow the room forever (re-answer new sessions/offers)
  // =========================
  async function joinRoom() {
    if (!localStream) throw new Error("Start media first.");

    const roomId = roomIdInput.value.trim();
    if (!roomId) throw new Error("Enter a room ID.");
    location.hash = roomId;

    const roomRef = doc(db, "rooms", roomId);

    let lastAnsweredSession = null;
    let unsubCallerCandidates = null;

    onSnapshot(roomRef, async (snap) => {
      const data = snap.data();

      if (!data?.offer || !data.session) {
        setStatus(callStatus, "Waiting for Person A to create the room/session…");
        return;
      }

      // already connected to this session
      if (lastAnsweredSession === data.session) return;

      setStatus(callStatus, `New session ${data.session} detected — connecting…`);

      // Clean old listeners/pc
      if (unsubCallerCandidates) { unsubCallerCandidates(); unsubCallerCandidates = null; }
      ensurePeerConnection();

      // IMPORTANT: clear our own stale callee candidates before we start answering a new session
      // (If A already cleared both sides, this is harmless; if not, this saves you.)
      await clearSubcollection(collection(roomRef, "calleeCandidates"));

      const callerCandidates = collection(roomRef, "callerCandidates");
      const calleeCandidates = collection(roomRef, "calleeCandidates");

      pc.onicecandidate = async (event) => {
        if (event.candidate) await addDoc(calleeCandidates, event.candidate.toJSON());
      };

      await pc.setRemoteDescription(new RTCSessionDescription(data.offer));

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      await updateDoc(roomRef, {
        answer: { type: answer.type, sdp: answer.sdp },
        session: data.session,
        answeredAt: Date.now()
      });

      lastAnsweredSession = data.session;

      // Add A's ICE candidates
      unsubCallerCandidates = onSnapshot(callerCandidates, (snapshot) => {
        snapshot.docChanges().forEach(async (change) => {
          if (change.type === "added" && pc) {
            try {
              await pc.addIceCandidate(new RTCIceCandidate(change.doc.data()));
            } catch (e) {}
          }
        });
      });

      pc.onconnectionstatechange = () => {
        setStatus(callStatus, `Connection: ${pc.connectionState} (session ${lastAnsweredSession})`);
      };
    });

    setStatus(callStatus, "Joined room. Waiting for session/offer…");
  }

  function copyInviteLink() {
    const roomId = roomIdInput.value.trim();
    if (!roomId) return;
    const url = `${location.origin}${location.pathname}#${roomId}`;
    navigator.clipboard.writeText(url);
    setStatus(callStatus, "Invite link copied to clipboard.");
  }

  // ---- Wire up UI ----
  startBtn.addEventListener("click", async () => {
    try { await startMedia(); }
    catch (e) { setStatus(mediaStatus, `Error: ${e.message}`); }
  });

  stopBtn.addEventListener("click", stopMedia);

  createBtn.addEventListener("click", async () => {
    try { await createRoom(); }
    catch (e) { setStatus(callStatus, `Error: ${e.message}`); }
  });

  joinBtn.addEventListener("click", async () => {
    try { await joinRoom(); }
    catch (e) { setStatus(callStatus, `Error: ${e.message}`); }
  });

  copyLinkBtn.addEventListener("click", copyInviteLink);

  roomIdInput.addEventListener("input", () => {
    copyLinkBtn.disabled = !roomIdInput.value.trim();
  });

  if (roomIdInput.value.trim()) {
    setStatus(callStatus, `Room ID detected in URL: ${roomIdInput.value.trim()}`);
  }
</script>
