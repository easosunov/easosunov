<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2-Person Video/Sound Communicator (WebRTC) + Diagnostics</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; flex: 1 1 320px; }
    .videos { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 900px) { .videos { grid-template-columns: 1fr; } }
    video { width: 100%; background: #000; border-radius: 12px; aspect-ratio: 16/9; }
    label { font-size: 12px; color: #444; display: block; margin: 8px 0 6px; }
    input[type="text"] { width: 100%; padding: 10px; border-radius: 10px; border: 1px solid #ccc; }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid #ccc; background: #f7f7f7; cursor: pointer; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .small { font-size: 12px; color: #555; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .status { margin-top: 10px; font-size: 13px; }
    #errorBox{
      display:none; margin: 12px 0; padding: 10px 12px;
      border: 1px solid #f3b5b5; background: #fff5f5; color: #7a1b1b;
      border-radius: 12px; white-space: pre-wrap;
    }
    #diag {
      height: 260px;
      overflow: auto;
      white-space: pre-wrap;
      background: #0b1020;
      color: #e6e6e6;
      border-radius: 12px;
      padding: 10px;
      font-size: 12px;
      line-height: 1.35;
    }
    .diagbar { display:flex; gap:10px; flex-wrap:wrap; margin: 10px 0; }
  </style>
</head>
<body>
  <h1>2-Person Video/Sound Communicator (WebRTC) + Diagnostics</h1>
  <div id="errorBox"></div>

  <div class="videos">
    <div class="card">
      <div><strong>Person A (You)</strong> — your webcam + mic</div>
      <video id="localVideo" playsinline autoplay muted></video>
      <div class="small">Muted so you don’t hear yourself (remote audio will play).</div>
    </div>

    <div class="card">
      <div><strong>Person B (Other)</strong> — remote webcam + mic</div>
      <video id="remoteVideo" playsinline autoplay></video>
      <div class="small">If audio doesn’t play, click the video once (browser autoplay rules).</div>
    </div>
  </div>

  <div class="row" style="margin-top: 12px;">
    <div class="card">
      <div><strong>Step 1:</strong> Start camera & mic</div>
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <div class="status" id="mediaStatus">Not started.</div>
    </div>

    <div class="card">
      <div><strong>Step 2:</strong> Create or join a room</div>

      <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
        <button id="createBtn" disabled>Create Room (Person A)</button>
        <button id="joinBtn" disabled>Join Room (Person B)</button>
      </div>

      <label for="roomId">Room ID</label>
      <input id="roomId" type="text" placeholder="(Create a room or paste one here)" />

      <div style="margin-top:10px;">
        <button id="copyLinkBtn" disabled>Copy Invite Link</button>
      </div>

      <div class="status" id="callStatus">No room yet.</div>
      <div class="small" style="margin-top:8px;">
        Tip: room ID is also taken from URL hash, like <span class="mono">.../webrtc.html#ROOM_ID</span>
      </div>
    </div>

    <div class="card" style="flex: 1 1 100%;">
      <div><strong>Diagnostics</strong></div>
      <div class="diagbar">
        <button id="clearLogBtn">Clear log</button>
        <button id="copyLogBtn">Copy log</button>
        <button id="statsBtn">Get stats now</button>
      </div>
      <div id="diag"></div>
      <div class="small" style="margin-top:8px;">
        If it says <span class="mono">ICE failed</span> and you only see <span class="mono">host</span> or no remote candidates,
        you need a TURN server.
      </div>
    </div>
  </div>

  <script type="module">
    const errorBox = document.getElementById("errorBox");
    const diagEl = document.getElementById("diag");
    const clearLogBtn = document.getElementById("clearLogBtn");
    const copyLogBtn = document.getElementById("copyLogBtn");
    const statsBtn = document.getElementById("statsBtn");

    function showError(e) {
      errorBox.style.display = "block";
      errorBox.textContent = String(e?.stack || e);
      console.error(e);
      log("ERROR: " + String(e?.stack || e));
    }
    window.addEventListener("error", (e) => showError(e.error || e.message || e));
    window.addEventListener("unhandledrejection", (e) => showError(e.reason || e));

    function ts() {
      const d = new Date();
      return d.toISOString().replace("T"," ").replace("Z","");
    }
    function log(msg) {
      const line = `[${ts()}] ${msg}\n`;
      diagEl.textContent += line;
      diagEl.scrollTop = diagEl.scrollHeight;
      console.log(msg);
    }

    clearLogBtn.addEventListener("click", () => { diagEl.textContent = ""; });
    copyLogBtn.addEventListener("click", async () => {
      await navigator.clipboard.writeText(diagEl.textContent);
      log("Copied log to clipboard.");
    });

    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
    import {
      getFirestore, doc, collection, addDoc, setDoc, getDoc, updateDoc,
      onSnapshot, getDocs, writeBatch
    } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyAg6TXwgejbPAyuEPEBqW9eHaZyLV4Wq98",
      authDomain: "easosunov-webrtc.firebaseapp.com",
      projectId: "easosunov-webrtc",
      storageBucket: "easosunov-webrtc.firebasestorage.app",
      messagingSenderId: "100169991412",
      appId: "1:100169991412:web:27ef6820f9a59add6b4aa1"
    };

    // UI
    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const createBtn = document.getElementById("createBtn");
    const joinBtn = document.getElementById("joinBtn");
    const copyLinkBtn = document.getElementById("copyLinkBtn");
    const roomIdInput = document.getElementById("roomId");
    const mediaStatus = document.getElementById("mediaStatus");
    const callStatus = document.getElementById("callStatus");

    function setStatus(el, msg) { el.textContent = msg; log(`STATUS(${el.id}): ${msg}`); }

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    if (location.hash && location.hash.length > 1) {
      roomIdInput.value = location.hash.substring(1);
      log("Room ID from URL hash: " + roomIdInput.value);
    }

    // WebRTC
    let localStream = null;
    let pc = null;

    // Firestore listeners
    let unsubRoom = null;
    let unsubCandidates = null;

    // Candidate counters
    let sentCandidates = 0;
    let recvCandidates = 0;

    // Stats polling
    let statsTimer = null;

    // IMPORTANT: STUN only. If ICE fails, you need TURN.
    const rtcConfig = {
      iceServers: [
        { urls: ["stun:stun.l.google.com:19302", "stun:stun1.l.google.com:19302"] }
      ]
    };

    function resetCandidateCounters() {
      sentCandidates = 0;
      recvCandidates = 0;
      log("Candidate counters reset.");
    }

    function stopStatsPolling() {
      if (statsTimer) clearInterval(statsTimer);
      statsTimer = null;
    }

    async function dumpStatsOnce(label="manual") {
      if (!pc) { log(`STATS(${label}): no pc`); return; }

      const report = await pc.getStats();
      let selectedPair = null;
      let localCandidate = null;
      let remoteCandidate = null;

      report.forEach(stat => {
        if (stat.type === "candidate-pair" && stat.nominated && stat.state) {
          if (!selectedPair || stat.selected) selectedPair = stat;
        }
      });

      if (selectedPair) {
        localCandidate = report.get(selectedPair.localCandidateId);
        remoteCandidate = report.get(selectedPair.remoteCandidateId);

        log(`STATS(${label}): pairState=${selectedPair.state} nominated=${selectedPair.nominated} selected=${selectedPair.selected ?? false} rtt=${selectedPair.currentRoundTripTime ?? "?"} bytesSent=${selectedPair.bytesSent ?? "?"} bytesRecv=${selectedPair.bytesReceived ?? "?"}`);
        if (localCandidate) {
          log(`STATS(${label}): localCand type=${localCandidate.candidateType} proto=${localCandidate.protocol} addr=${localCandidate.address ?? localCandidate.ip ?? "?"}:${localCandidate.port ?? "?"}`);
        }
        if (remoteCandidate) {
          log(`STATS(${label}): remoteCand type=${remoteCandidate.candidateType} proto=${remoteCandidate.protocol} addr=${remoteCandidate.address ?? remoteCandidate.ip ?? "?"}:${remoteCandidate.port ?? "?"}`);
        }
      } else {
        // Still useful: show ICE and PC states
        log(`STATS(${label}): no nominated candidate pair yet. pc=${pc.connectionState} iceConn=${pc.iceConnectionState} iceGather=${pc.iceGatheringState} sentCand=${sentCandidates} recvCand=${recvCandidates}`);
      }
    }

    statsBtn.addEventListener("click", () => dumpStatsOnce("button").catch(showError));

    function startStatsPolling() {
      stopStatsPolling();
      statsTimer = setInterval(() => {
        dumpStatsOnce("poll").catch(() => {});
      }, 3000);
    }

    function closePeer() {
      stopStatsPolling();
      if (pc) {
        log("Closing RTCPeerConnection");
        pc.onicecandidate = null;
        pc.ontrack = null;
        pc.onconnectionstatechange = null;
        pc.oniceconnectionstatechange = null;
        pc.onicegatheringstatechange = null;
        pc.onsignalingstatechange = null;
        pc.close();
        pc = null;
      }
      remoteVideo.srcObject = null;
    }

    function ensurePeerConnection() {
      closePeer();
      resetCandidateCounters();

      pc = new RTCPeerConnection(rtcConfig);
      log("Created RTCPeerConnection");

      pc.onicegatheringstatechange = () => log(`ICE gathering state: ${pc.iceGatheringState}`);
      pc.onsignalingstatechange = () => log(`Signaling state: ${pc.signalingState}`);
      pc.oniceconnectionstatechange = () => log(`ICE connection state: ${pc.iceConnectionState}`);
      pc.onconnectionstatechange = () => log(`Peer connection state: ${pc.connectionState}`);

      const remoteStream = new MediaStream();
      remoteVideo.srcObject = remoteStream;

      pc.ontrack = (event) => {
        log(`ontrack: streams=${event.streams.length} tracks=${event.track.kind}`);
        event.streams[0].getTracks().forEach(t => remoteStream.addTrack(t));
        remoteVideo.muted = false;
        remoteVideo.play().catch(() => {});
      };

      pc.onicecandidate = async (event) => {
        if (event.candidate) {
          sentCandidates++;
          log(`ICE candidate gathered (#${sentCandidates}): ${event.candidate.type} ${event.candidate.protocol} ${event.candidate.address ?? ""}`);
          // stored by caller/join logic
        } else {
          log("ICE candidate gathering complete (null candidate)");
        }
      };

      if (!localStream) throw new Error("Local media not started yet.");
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      startStatsPolling();
    }

    async function clearSubcollection(colRef) {
      const snap = await getDocs(colRef);
      if (snap.empty) return;
      const batch = writeBatch(db);
      snap.forEach(d => batch.delete(d.ref));
      await batch.commit();
      log(`Cleared subcollection ${colRef.path} docs=${snap.size}`);
    }

    async function startMedia() {
      setStatus(mediaStatus, "Requesting camera/mic permission…");
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      localVideo.srcObject = localStream;

      setStatus(mediaStatus, "Camera/mic started.");
      startBtn.disabled = true;
      stopBtn.disabled = false;
      createBtn.disabled = false;
      joinBtn.disabled = false;
      copyLinkBtn.disabled = !roomIdInput.value.trim();
    }

    async function stopMedia() {
      if (unsubRoom) { unsubRoom(); unsubRoom = null; }
      if (unsubCandidates) { unsubCandidates(); unsubCandidates = null; }

      closePeer();

      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
      localVideo.srcObject = null;

      setStatus(mediaStatus, "Stopped.");
      setStatus(callStatus, "Call ended.");
      startBtn.disabled = false;
      stopBtn.disabled = true;
      createBtn.disabled = true;
      joinBtn.disabled = true;
      copyLinkBtn.disabled = true;
    }

    async function createRoom() {
      if (!localStream) throw new Error("Start media first.");

      // stop old listeners
      if (unsubRoom) { unsubRoom(); unsubRoom = null; }
      if (unsubCandidates) { unsubCandidates(); unsubCandidates = null; }

      let roomRef;
      const existingId = roomIdInput.value.trim();

      if (existingId) {
        roomRef = doc(db, "rooms", existingId);
      } else {
        roomRef = doc(collection(db, "rooms"));
        roomIdInput.value = roomRef.id;
        location.hash = roomRef.id;
      }

      log(`CreateRoom: roomId=${roomRef.id}`);

      // clean old junk
      await clearSubcollection(collection(roomRef, "callerCandidates"));
      await clearSubcollection(collection(roomRef, "calleeCandidates"));
      await setDoc(roomRef, { offer: null, answer: null, updatedAt: Date.now() }, { merge: true });

      ensurePeerConnection();

      const callerCandidates = collection(roomRef, "callerCandidates");
      const calleeCandidates = collection(roomRef, "calleeCandidates");

      // store gathered candidates
      pc.onicecandidate = async (event) => {
        if (event.candidate) {
          sentCandidates++;
          await addDoc(callerCandidates, event.candidate.toJSON());
          log(`Stored callerCandidate (#${sentCandidates})`);
        } else {
          log("Caller ICE complete");
        }
      };

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      log("Set localDescription(offer)");

      await setDoc(roomRef, {
        offer: { type: offer.type, sdp: offer.sdp },
        answer: null,
        updatedAt: Date.now()
      }, { merge: true });

      setStatus(callStatus, `Room active. Room ID: ${roomRef.id}`);
      copyLinkBtn.disabled = false;

      // listen for answer
      unsubRoom = onSnapshot(roomRef, async (snap) => {
        const data = snap.data();
        if (!data?.answer) return;
        if (pc.currentRemoteDescription) return;

        await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
        log("Set remoteDescription(answer)");
        setStatus(callStatus, "Connected (answer received).");
      });

      // listen for callee candidates
      unsubCandidates = onSnapshot(calleeCandidates, (snapshot) => {
        snapshot.docChanges().forEach(async (change) => {
          if (change.type !== "added" || !pc) return;
          recvCandidates++;
          const c = change.doc.data();
          log(`Received calleeCandidate (#${recvCandidates})`);
          try { await pc.addIceCandidate(new RTCIceCandidate(c)); }
          catch (e) { log("addIceCandidate error: " + e); }
        });
      });
    }

    async function joinRoom() {
      if (!localStream) throw new Error("Start media first.");

      // stop old listeners
      if (unsubRoom) { unsubRoom(); unsubRoom = null; }
      if (unsubCandidates) { unsubCandidates(); unsubCandidates = null; }

      const roomId = roomIdInput.value.trim();
      if (!roomId) throw new Error("Enter a room ID.");
      location.hash = roomId;

      const roomRef = doc(db, "rooms", roomId);
      const roomSnap = await getDoc(roomRef);
      if (!roomSnap.exists()) throw new Error("Room not found.");

      log(`JoinRoom: roomId=${roomId}`);

      // clean stale callee candidates for repeated joins
      await clearSubcollection(collection(roomRef, "calleeCandidates"));
      await updateDoc(roomRef, { answer: null, answeredAt: null });

      ensurePeerConnection();

      const callerCandidates = collection(roomRef, "callerCandidates");
      const calleeCandidates = collection(roomRef, "calleeCandidates");

      pc.onicecandidate = async (event) => {
        if (event.candidate) {
          sentCandidates++;
          await addDoc(calleeCandidates, event.candidate.toJSON());
          log(`Stored calleeCandidate (#${sentCandidates})`);
        } else {
          log("Callee ICE complete");
        }
      };

      const roomData = roomSnap.data();
      if (!roomData?.offer) {
        setStatus(callStatus, "No offer yet. Ask Person A to create the room.");
        return;
      }

      await pc.setRemoteDescription(new RTCSessionDescription(roomData.offer));
      log("Set remoteDescription(offer)");

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      log("Set localDescription(answer)");

      await updateDoc(roomRef, {
        answer: { type: answer.type, sdp: answer.sdp },
        answeredAt: Date.now()
      });

      setStatus(callStatus, "Joined room. Connecting…");

      // listen for caller candidates
      unsubCandidates = onSnapshot(callerCandidates, (snapshot) => {
        snapshot.docChanges().forEach(async (change) => {
          if (change.type !== "added" || !pc) return;
          recvCandidates++;
          const c = change.doc.data();
          log(`Received callerCandidate (#${recvCandidates})`);
          try { await pc.addIceCandidate(new RTCIceCandidate(c)); }
          catch (e) { log("addIceCandidate error: " + e); }
        });
      });

      // also listen to pc states to recommend TURN
      pc.oniceconnectionstatechange = () => {
        log(`ICE connection state: ${pc.iceConnectionState} (sent=${sentCandidates} recv=${recvCandidates})`);
        if (pc.iceConnectionState === "failed") {
          log("DIAG: ICE failed. This usually means you need a TURN server OR candidates are not being exchanged.");
        }
        if (pc.iceConnectionState === "checking" && recvCandidates === 0) {
          log("DIAG: Still checking but received 0 remote candidates so far (signaling issue).");
        }
      };
    }

    function copyInviteLink() {
      const roomId = roomIdInput.value.trim();
      if (!roomId) return;
      const url = `${location.origin}${location.pathname}#${roomId}`;
      navigator.clipboard.writeText(url);
      setStatus(callStatus, "Invite link copied to clipboard.");
    }

    // UI wiring
    startBtn.addEventListener("click", async () => {
      try { await startMedia(); } catch (e) { setStatus(mediaStatus, `Error: ${e.message}`); showError(e); }
    });

    stopBtn.addEventListener("click", () => stopMedia().catch(showError));

    createBtn.addEventListener("click", async () => {
      try { await createRoom(); } catch (e) { setStatus(callStatus, `Error: ${e.message}`); showError(e); }
    });

    joinBtn.addEventListener("click", async () => {
      try { await joinRoom(); } catch (e) { setStatus(callStatus, `Error: ${e.message}`); showError(e); }
    });

    copyLinkBtn.addEventListener("click", copyInviteLink);

    roomIdInput.addEventListener("input", () => {
      copyLinkBtn.disabled = !roomIdInput.value.trim();
    });

    if (roomIdInput.value.trim()) {
      setStatus(callStatus, `Room ID detected in URL: ${roomIdInput.value.trim()}`);
    }

    log("Diagnostics ready. If connection fails, click 'Copy log' and send it here.");
  </script>
</body>
</html>
