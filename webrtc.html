<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>2-Person Video/Sound Communicator (WebRTC)</title>

<style>
body{font-family:system-ui;margin:16px}
h1{font-size:20px;margin:0 0 10px}
.row{display:flex;gap:12px;flex-wrap:wrap}
.card{border:1px solid #ddd;border-radius:12px;padding:12px;flex:1 1 320px}
.videos{display:grid;grid-template-columns:1fr 1fr;gap:12px}
@media (max-width: 720px){ .videos{grid-template-columns:1fr} }
video{width:100%;background:#000;border-radius:12px;aspect-ratio:16/9}
button{padding:10px 12px;border-radius:10px;border:1px solid #ccc;background:#f7f7f7;cursor:pointer}
button:disabled{opacity:.6;cursor:not-allowed}
input{padding:10px 12px;border-radius:10px;border:1px solid #ccc;width:100%}
.status{font-size:13px;margin-top:8px}
.small{font-size:12px;color:#555;margin-top:6px}

#errorBox{
  display:none;margin:12px 0;padding:10px;
  border:1px solid #f3b5b5;background:#fff5f5;
  color:#7a1b1b;border-radius:12px;white-space:pre-wrap
}

/* LOGIN OVERLAY */
#loginOverlay{
  position:fixed; inset:0; z-index:9999;
  background:rgba(0,0,0,.55);
  display:flex; align-items:center; justify-content:center;
}
#loginCard{
  width:min(520px,calc(100% - 24px));
  background:#fff; border-radius:14px;
  padding:16px;
  box-shadow:0 10px 30px rgba(0,0,0,.35);
}
#loginRow{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
#logoutBtn{float:right}
#app.locked{filter:blur(2px);opacity:.35;pointer-events:none;user-select:none}

/* DIAGNOSTICS */
#diagBox{
  display:none;
  margin-top:8px;
  max-height:220px;
  overflow:auto;
  background:#111;
  color:#0f0;
  padding:8px;
  border-radius:8px;
  font-size:12px;
  white-space:pre-wrap;
}
.diagActions{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}

/* INCOMING CALL MODAL */
#incomingOverlay{
  position:fixed; inset:0; z-index:9998;
  background:rgba(0,0,0,.55);
  display:none; align-items:center; justify-content:center;
}
#incomingCard{
  width:min(520px,calc(100% - 24px));
  background:#fff; border-radius:14px;
  padding:16px;
  box-shadow:0 10px 30px rgba(0,0,0,.35);
}
.incomingActions{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
#answerBtn{background:#e8fff0;border-color:#bdeccc}
#declineBtn{background:#fff0f0;border-color:#f1bcbc}
</style>
</head>

<body>
<h1>2-Person Video/Sound Communicator (WebRTC)</h1>

<div id="errorBox"></div>

<!-- INCOMING CALL -->
<div id="incomingOverlay">
  <div id="incomingCard">
    <h2 style="margin:0 0 8px;font-size:18px;">Incoming call</h2>
    <div id="incomingText" class="status">Someone is calling…</div>
    <div class="small">If you don’t hear ringing, tap once anywhere to enable sound.</div>
    <div class="incomingActions">
      <button id="answerBtn">Answer</button>
      <button id="declineBtn">Decline</button>
    </div>
  </div>
</div>

<!-- LOGIN -->
<div id="loginOverlay">
  <div id="loginCard">
    <button id="logoutBtn" style="display:none;">Logout</button>
    <h2 style="margin:0 0 8px;font-size:18px;">Sign in required</h2>
    <div class="small">Only approved users can access this communicator.</div>

    <label class="small">Email</label>
    <input id="emailInput" type="email" placeholder="you@example.com" autocomplete="username"/>

    <label class="small">Password</label>
    <input id="passInput" type="password" placeholder="••••••••" autocomplete="current-password"/>

    <div id="loginRow">
      <button id="loginBtn">Login</button>
    </div>
    <div id="loginStatus" class="status">Please sign in.</div>
    <div class="small">Tip: If you mistype, you will see a message here (no pink error box).</div>
  </div>
</div>

<div id="app" class="locked">

  <div class="videos">
    <div class="card">
      <b>Person A (You)</b>
      <video id="localVideo" autoplay muted playsinline></video>
      <div class="small">Muted so you don’t hear yourself.</div>
    </div>
    <div class="card">
      <b>Person B (Other)</b>
      <video id="remoteVideo" autoplay playsinline></video>
      <div class="small">If audio doesn’t play, click the video once.</div>
    </div>
  </div>

  <!-- PHONE CALLING -->
  <div class="row" style="margin-top:12px">
    <div class="card">
      <b>Phone calling</b><br/><br/>

      <div class="small">Your phone number (used only for in-app lookup)</div>
      <input id="myPhoneInput" placeholder="+15551234567"/>
      <div style="margin-top:8px;display:flex;gap:10px;flex-wrap:wrap">
        <button id="savePhoneBtn" disabled>Save My Number</button>
        <button id="testSoundBtn" disabled>Test Ring Sound</button>
        <button id="enablePushBtn" disabled>Enable Push Notifications</button>
      </div>
      <div class="status" id="phoneStatus">Not set.</div>
      <div class="status" id="pushStatus">Push: not enabled.</div>

      <hr style="border:none;border-top:1px solid #eee;margin:12px 0">

      <div class="small">Call another user by phone number</div>
      <input id="calleePhoneInput" placeholder="+15557654321"/>
      <div style="margin-top:8px;display:flex;gap:10px;flex-wrap:wrap">
        <button id="callBtn" disabled>Call</button>
        <button id="hangupBtn" disabled>Hang up</button>
      </div>
      <div class="status" id="phoneCallStatus">Idle.</div>
      <div class="small">Tip: both users must be signed in and have saved their phone number.</div>
      <div class="small">
        Push requires an extra file at site root: <code>/firebase-messaging-sw.js</code>, plus a Cloud Function to send push.
      </div>
    </div>
  </div>

  <!-- ORIGINAL STEPS -->
  <div class="row" style="margin-top:12px">
    <div class="card">
      <b>Step 1</b><br/><br/>
      <button id="startBtn" disabled>Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <div class="status" id="mediaStatus">Not started.</div>
    </div>

    <div class="card">
      <b>Step 2</b><br/><br/>
      <button id="createBtn" disabled>Create Room</button>
      <button id="joinBtn" disabled>Join Room</button>
      <div class="small" style="margin-top:8px">Room ID</div>
      <input id="roomId" placeholder="Room ID"/>
      <div style="margin-top:8px">
        <button id="copyLinkBtn" disabled>Copy Invite</button>
      </div>
      <div class="status" id="callStatus">No room yet.</div>
      <div class="small">Invite format: <code>.../webrtc.html#ROOM_ID</code></div>
    </div>
  </div>

  <div class="card" style="margin-top:12px">
    <button id="diagBtn">Diagnostics</button>
    <div class="diagActions">
      <button id="copyDiagBtn" disabled>Copy log</button>
      <button id="clearDiagBtn" disabled>Clear log</button>
    </div>
    <pre id="diagBox"></pre>
    <div class="small">Diagnostics are hidden by default. Click “Diagnostics” to show/hide.</div>
  </div>
</div>

<script type="module">
console.log("APP VERSION:", "2025-12-31-1");

/* ======== CONFIG ======== */
const PUBLIC_VAPID_KEY = "BCB4B8uFw0ZJuzKHLBCJO22NNpupe88jBwkriTwvQALDpWUeJ3umIkNJTLrb0L_eLeu2HyBNbogHc67YfNzM";
console.log("PUBLIC_VAPID_KEY CHECK:", PUBLIC_VAPID_KEY.slice(0, 10));

/* ================== ELEMENTS ================== */
const errorBox = document.getElementById("errorBox");

const loginOverlay = document.getElementById("loginOverlay");
const loginBtn = document.getElementById("loginBtn");
const logoutBtn = document.getElementById("logoutBtn");
const loginStatus = document.getElementById("loginStatus");
const emailInput = document.getElementById("emailInput");
const passInput = document.getElementById("passInput");
const appRoot = document.getElementById("app");

const localVideo = document.getElementById("localVideo");
const remoteVideo = document.getElementById("remoteVideo");
const startBtn = document.getElementById("startBtn");
const stopBtn  = document.getElementById("stopBtn");
const createBtn= document.getElementById("createBtn");
const joinBtn  = document.getElementById("joinBtn");
const copyLinkBtn = document.getElementById("copyLinkBtn");
const roomIdInput = document.getElementById("roomId");
const mediaStatus = document.getElementById("mediaStatus");
const callStatus  = document.getElementById("callStatus");

const diagBtn = document.getElementById("diagBtn");
const diagBox = document.getElementById("diagBox");
const copyDiagBtn = document.getElementById("copyDiagBtn");
const clearDiagBtn = document.getElementById("clearDiagBtn");

/* Phone call UI */
const myPhoneInput = document.getElementById("myPhoneInput");
const savePhoneBtn = document.getElementById("savePhoneBtn");
const phoneStatus = document.getElementById("phoneStatus");
const pushStatus = document.getElementById("pushStatus");
const calleePhoneInput = document.getElementById("calleePhoneInput");
const callBtn = document.getElementById("callBtn");
const hangupBtn = document.getElementById("hangupBtn");
const phoneCallStatus = document.getElementById("phoneCallStatus");
const testSoundBtn = document.getElementById("testSoundBtn");
const enablePushBtn = document.getElementById("enablePushBtn");

/* Incoming modal */
const incomingOverlay = document.getElementById("incomingOverlay");
const incomingText = document.getElementById("incomingText");
const answerBtn = document.getElementById("answerBtn");
const declineBtn = document.getElementById("declineBtn");

const setStatus = (el,msg)=> el.textContent = msg;

/* ================== DIAGNOSTICS ================== */
let diagVisible = false;
const diagLog = [];
function logDiag(msg){
  const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
  diagLog.push(line);
  console.log(line);
  if (diagVisible) {
    diagBox.textContent = diagLog.join("\n");
    diagBox.scrollTop = diagBox.scrollHeight;
  }
  copyDiagBtn.disabled = diagLog.length === 0;
  clearDiagBtn.disabled = diagLog.length === 0;
}
diagBtn.onclick = () => {
  diagVisible = !diagVisible;
  diagBox.style.display = diagVisible ? "block" : "none";
  diagBtn.textContent = diagVisible ? "Hide diagnostics" : "Diagnostics";
  if (diagVisible) {
    diagBox.textContent = diagLog.join("\n");
    diagBox.scrollTop = diagBox.scrollHeight;
  }
};
clearDiagBtn.onclick = () => {
  diagLog.length = 0;
  if (diagVisible) diagBox.textContent = "";
  copyDiagBtn.disabled = true;
  clearDiagBtn.disabled = true;
  logDiag("Diagnostics cleared.");
};
copyDiagBtn.onclick = async () => {
  const text = diagLog.join("\n");
  if (!text) return;
  try{
    await navigator.clipboard.writeText(text);
    logDiag("Copied diagnostics to clipboard.");
  }catch{
    window.prompt("Copy diagnostics:", text);
  }
};

/* ================== ERROR HANDLING ================== */
function showError(e){
  const code = e?.code ? `\ncode: ${e.code}` : "";
  const msg  = e?.message ? `\nmessage: ${e.message}` : "";
  errorBox.style.display = "block";
  errorBox.textContent = `${String(e?.stack || "")}${code}${msg}`.trim() || String(e);
  logDiag("ERROR: " + String(e?.code || "") + " :: " + String(e?.message || e));
}
function hideErrorBox(){
  errorBox.style.display = "none";
  errorBox.textContent = "";
}
window.addEventListener("error", (e)=> showError(e.error || e.message || e));
window.addEventListener("unhandledrejection", (e)=> showError(e.reason || e));
emailInput.addEventListener("input", () => { hideErrorBox(); loginStatus.textContent=""; });
passInput.addEventListener("input", () => { hideErrorBox(); loginStatus.textContent=""; });

/* ================== FIREBASE ================== */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
import {
  getFirestore, doc, collection, addDoc, setDoc, getDoc, updateDoc,
  onSnapshot, getDocs, writeBatch, query, where, limit, orderBy, serverTimestamp
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";
import { getMessaging, getToken, onMessage } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-messaging.js";
import {
  getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut,
  setPersistence, inMemoryPersistence
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";

const app = initializeApp({
  apiKey:"AIzaSyAg6TXwgejbPAyuEPEBqW9eHaZyLV4Wq98",
  authDomain:"easosunov-webrtc.firebaseapp.com",
  projectId:"easosunov-webrtc",
  storageBucket:"easosunov-webrtc.firebasestorage.app",
  messagingSenderId:"100169991412",
  appId:"1:100169991412:web:27ef6820f9a59add6b4aa1"
});
const db = getFirestore(app);
const auth = getAuth(app);

/* Force login every time (no stored session) */
await setPersistence(auth, inMemoryPersistence);

/* UID allowlist */
async function enforceAllowlist(user){
  const ref = doc(db, "allowlistUids", user.uid);
  const snap = await getDoc(ref);
  if(!snap.exists() || snap.data()?.enabled !== true){
    try{ await signOut(auth); }catch{}
    throw new Error("This account is not approved. Ask admin to allowlist your UID.");
  }
}

/* ================== AUTH GATE ================== */
let isAuthed = false;
let myUid = null;
let pendingIncomingCallWhileLoggedOut = null;

function requireAuthOrPrompt(){
  if (isAuthed) return true;
  loginOverlay.style.display = "flex";
  appRoot.classList.add("locked");
  loginStatus.textContent = "Please sign in first.";
  return false;
}

loginBtn.onclick = async () => {
  hideErrorBox();
  loginStatus.textContent = "Signing in…";
  try {
    await signInWithEmailAndPassword(auth, emailInput.value.trim(), passInput.value);
  } catch (e) {
    loginStatus.textContent = `Login failed: ${e?.code || "unknown"}`;
    try { logDiag("LOGIN ERROR PROPS: " + JSON.stringify(e, Object.getOwnPropertyNames(e))); } catch {}
    showError(e);
  }
};

logoutBtn.onclick = async () => { try { await signOut(auth); } catch(e){ showError(e); } };

/* ================== URL OPEN (from push click) ================== */
(function handlePushOpen(){
  try{
    const qs = new URLSearchParams(location.search);
    const callId = qs.get("callId");
    const roomId = qs.get("roomId");
    const fromPhone = qs.get("fromPhone");
    const toPhone = qs.get("toPhone");

    if(callId && roomId){
      incomingText.textContent = `Call from ${fromPhone || "unknown"}…`;
      incomingOverlay.style.display = "flex";
      if (typeof startRingtone === "function") startRingtone();

      pendingIncomingCallWhileLoggedOut = {
        id: callId,
        data: { roomId, fromPhone, toPhone }
      };

      roomIdInput.value = roomId;
    }
  }catch(e){
    console.warn("Push open parse failed", e);
  }
})();

/* ================== URL HASH / AUTOJOIN MODE ================== */
const openedFromInvite = (location.hash.length > 1);
let suppressAutoJoin = false;

if (openedFromInvite) {
  roomIdInput.value = location.hash.slice(1);
  setStatus(callStatus, "Room ID detected in URL.");
  logDiag("Room ID from URL hash: " + roomIdInput.value);
}

/* ================== WEBRTC ================== */
let rtcConfig = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

async function loadIceServers() {
  logDiag("Fetching ICE servers …");
  const r = await fetch("https://turn-token.easosunov.workers.dev/ice");
  if (!r.ok) throw new Error("ICE fetch failed: " + r.status);
  const data = await r.json();
  rtcConfig = { iceServers: data.iceServers };
  logDiag("ICE servers loaded: " + (data.iceServers?.length || 0));
}

let localStream = null;
let pc = null;

/* CRITICAL: when making a phone call, pin the room id so restarts NEVER jump rooms */
let pinnedRoomId = null;

function closePeer(){
  if(pc){
    pc.onicecandidate=null;
    pc.ontrack=null;
    pc.onconnectionstatechange=null;
    pc.oniceconnectionstatechange=null;
    try{ pc.close(); }catch{}
    pc=null;
  }
  remoteVideo.srcObject = null;
}

async function ensurePeer() {
  closePeer();

  if (!rtcConfig || !rtcConfig.iceServers || rtcConfig.iceServers.length === 0) {
    await loadIceServers();
  }

  pc = new RTCPeerConnection(rtcConfig);
  logDiag("Created RTCPeerConnection with ICE servers");

  const rs = new MediaStream();
  remoteVideo.srcObject = rs;

  pc.ontrack = (e) => {
    e.streams[0].getTracks().forEach(t => rs.addTrack(t));
    remoteVideo.muted = false;
    remoteVideo.play().catch(() => {});
    logDiag(`ontrack: ${e.streams[0].getTracks().map(t=>t.kind).join(",")}`);
  };

  pc.onconnectionstatechange = () => { if (pc) logDiag("pc.connectionState=" + pc.connectionState); };
  pc.oniceconnectionstatechange = () => { if (pc) logDiag("pc.iceConnectionState=" + pc.iceConnectionState); };

  if (!localStream) throw new Error("Local media not started.");
  localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
}

/* ================== FIRESTORE HELPERS ================== */
async function clearSub(col){
  const s = await getDocs(col);
  if(s.empty) return;
  const b = writeBatch(db);
  s.forEach(d=>b.delete(d.ref));
  await b.commit();
  logDiag(`Cleared subcollection ${col.path} docs=${s.size}`);
}

/* ================== UI HELPERS ================== */
function refreshCopyInviteState(){
  const hasRoomId = !!roomIdInput.value.trim();
  copyLinkBtn.disabled = !(isAuthed && hasRoomId);
}

/* Call button enable/disable */
function normalizePhone(p){ return String(p || "").trim().replace(/\s+/g,""); }
function isE164(p){ return /^\+\d{5,20}$/.test(p); }
function refreshCallButtonState(){
  const ok = isAuthed && isE164(normalizePhone(calleePhoneInput.value));
  callBtn.disabled = !ok;
}

/* ================== MEDIA + AUTOJOIN ================== */
let startingPromise = null;
let autoJoinDone = false;
let autoJoinScheduled = false;
let autoJoinTimer = null;

async function startMedia(opts={skipAutoJoin:false}){
  if(!requireAuthOrPrompt()) return;

  logDiag("enablePush(): Notification in window = " + ("Notification" in window));
  logDiag("enablePush(): serviceWorker in navigator = " + ("serviceWorker" in navigator));
  logDiag("enablePush(): Notification.permission = " + (("Notification" in window) ? Notification.permission : "n/a"));
  logDiag("enablePush(): PUBLIC_VAPID_KEY set = " + (!!PUBLIC_VAPID_KEY && !String(PUBLIC_VAPID_KEY).includes("PASTE_")));

  if(localStream){
    if(!opts.skipAutoJoin) scheduleAutoJoin();
    return;
  }
  if(startingPromise) return startingPromise;

  startingPromise = (async()=>{
    hideErrorBox();

    setStatus(mediaStatus,"Requesting camera/mic…");
    logDiag("Requesting getUserMedia…");

    localStream = await navigator.mediaDevices.getUserMedia({video:true,audio:true});
    localVideo.srcObject = localStream;

    setStatus(mediaStatus,"Camera/mic started.");
    logDiag("Camera/mic started (stream attached).");

    localVideo.onloadedmetadata = async () => {
      try { await localVideo.play(); } catch {}
      setStatus(mediaStatus,"Camera/mic started.");
      logDiag("Local video playing.");
    };

    await loadIceServers();

    startBtn.disabled = true;
    stopBtn.disabled  = false;
    createBtn.disabled = false;
    joinBtn.disabled   = false;
  })();

  try{ await startingPromise; }
  finally{ startingPromise = null; }

  if(!opts.skipAutoJoin) scheduleAutoJoin();
}

function cancelPendingAutoJoin(){
  autoJoinScheduled = false;
  if (autoJoinTimer) { clearTimeout(autoJoinTimer); autoJoinTimer = null; }
}

function scheduleAutoJoin(){
  if (!openedFromInvite) return;
  if (suppressAutoJoin) return;
  if (autoJoinScheduled) return;

  cancelPendingAutoJoin();
  autoJoinScheduled = true;

  autoJoinTimer = setTimeout(async ()=>{
    autoJoinScheduled = false;
    autoJoinTimer = null;
    try{ await autoJoinIfNeeded(); }
    catch(e){
      setStatus(callStatus, `Auto-join failed: ${e?.message || e}`);
      showError(e);
    }
  }, 0);
}

async function autoJoinIfNeeded(){
  if(autoJoinDone) return;
  if(!roomIdInput.value.trim()) return;

  autoJoinDone = true;
  setStatus(callStatus,"Auto-joining room…");
  logDiag("Auto-joining triggered.");

  try{
    await joinRoom();
  }catch(e){
    autoJoinDone = false;
    throw e;
  }
}

/* ================== LISTENERS ================== */
let unsubRoomA=null, unsubCalleeA=null;
let unsubRoomB=null, unsubCallerB=null;

function stopListeners(){
  if(unsubRoomA){ unsubRoomA(); unsubRoomA=null; }
  if(unsubCalleeA){ unsubCalleeA(); unsubCalleeA=null; }
  if(unsubRoomB){ unsubRoomB(); unsubRoomB=null; }
  if(unsubCallerB){ unsubCallerB(); unsubCallerB=null; }
}

/* ================== STOP ================== */
function stopAll(){
  stopListeners();
  closePeer();
  stopCallListeners();
  stopIncomingUI();

  if(localStream){
    localStream.getTracks().forEach(t=>t.stop());
    localStream=null;
  }
  localVideo.srcObject=null;

  startBtn.disabled = !isAuthed;
  stopBtn.disabled = true;
  createBtn.disabled = true;
  joinBtn.disabled = true;

  setStatus(mediaStatus,"Not started.");
  setStatus(callStatus,"No room yet.");

  autoJoinDone = false;
  suppressAutoJoin = false;
  cancelPendingAutoJoin();

  refreshCopyInviteState();

  hangupBtn.disabled = true;
  callBtn.disabled = !isAuthed;
  setStatus(phoneCallStatus, "Idle.");

  pinnedRoomId = null;
}
stopBtn.onclick = () => stopAll();

/* ================== REJOIN SUPPORT ================== */
let lastSeenJoinRequestA = 0;
let lastAnsweredSessionB = null;
let bRetryTimer = null;

function clearBRetry(){
  if(bRetryTimer){ clearTimeout(bRetryTimer); bRetryTimer=null; }
}

async function requestFreshOffer(roomRef){
  lastAnsweredSessionB = null;
  await setDoc(roomRef, { joinRequest: Date.now() }, { merge:true });
  logDiag("Requested fresh offer (joinRequest).");
}

/* ================== ROOM A ================== */
let createAttemptA = 0;

async function createRoom(options={updateHash:true, reuseRoomIdInput:true, fixedRoomId:null}){
  if(!requireAuthOrPrompt()) return null;

  suppressAutoJoin = true;
  autoJoinDone = true;
  cancelPendingAutoJoin();

  stopListeners();
  clearBRetry();

  await startMedia({ skipAutoJoin:true });

  const myAttempt = ++createAttemptA;

  const existing =
    (options.fixedRoomId ? String(options.fixedRoomId).trim() : "") ||
    (pinnedRoomId ? String(pinnedRoomId).trim() : "") ||
    (options.reuseRoomIdInput ? roomIdInput.value.trim() : "");

  const roomRef = existing ? doc(db, "rooms", existing) : doc(collection(db, "rooms"));

  roomIdInput.value = roomRef.id;
  if (options.updateHash) location.hash = roomRef.id;

  refreshCopyInviteState();
  logDiag("CreateRoom: roomId=" + roomRef.id);

  const caller = collection(roomRef,"callerCandidates");

  const snap = await getDoc(roomRef);
  const prev = snap.exists() ? (snap.data().session || 0) : 0;
  const session = Number(prev) + 1;

  if(myAttempt !== createAttemptA) return null;

  await clearSub(caller);
  await clearSub(callee);

  if(myAttempt !== createAttemptA) return null;

  await ensurePeer();

  pc.onicecandidate = (e)=>{
    if(e.candidate){
      addDoc(caller, { session, ...e.candidate.toJSON() }).catch(()=>{});
    }
  };

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  await setDoc(roomRef, {
    session,
    offer: { type: offer.type, sdp: offer.sdp },
    answer: null,
    updatedAt: Date.now()
  }, { merge:true });

  setStatus(callStatus, `Room active (session ${session}).`);
  logDiag(`Room written. session=${session}`);

  unsubRoomA = onSnapshot(roomRef, async (s)=>{
    if(myAttempt !== createAttemptA) return;
    const d = s.data();
    if(!d) return;

    if(d.joinRequest && d.joinRequest > lastSeenJoinRequestA){
      lastSeenJoinRequestA = d.joinRequest;
      setStatus(callStatus, "Join request received — restarting session…");
      logDiag("JoinRequest seen => restarting offer/session.");
      setTimeout(()=>createRoom({ ...options, fixedRoomId: roomRef.id, reuseRoomIdInput: true }).catch(()=>{}), 150);
      return;
    }

    if(d.answer && d.session === session && pc && pc.signalingState === "have-local-offer" && !pc.currentRemoteDescription){
      try{
        await pc.setRemoteDescription(d.answer);
        setStatus(callStatus, `Connected (session ${session}).`);
        logDiag("Applied remote answer.");
      }catch(e){
        logDiag("setRemoteDescription(answer) failed: " + (e?.message || e));
        setStatus(callStatus, "Answer failed — restarting session…");
        setTimeout(()=>createRoom({ ...options, fixedRoomId: roomRef.id, reuseRoomIdInput: true }).catch(()=>{}), 200);
      }
    }
  });

  unsubCalleeA = onSnapshot(callee, (ss)=>{
    ss.docChanges().forEach(ch=>{
      if(ch.type !== "added" || !pc) return;
      const c = ch.doc.data();
      if(c.session !== session) return;
      try{ pc.addIceCandidate(c); }catch{}
    });
  });

  return { roomId: roomRef.id, roomRef };
}

/* ================== ROOM B ================== */
let joinAttemptB = 0;

async function joinRoom(){
  if(!requireAuthOrPrompt()) return;

  suppressAutoJoin = false;
  await startMedia({ skipAutoJoin:true });

  const myAttempt = ++joinAttemptB;
  stopListeners();
  clearBRetry();

  const roomId = roomIdInput.value.trim();
  if(!roomId) throw new Error("Room ID is empty.");
  location.hash = roomId;

  logDiag("JoinRoom: roomId=" + roomId);

  const roomRef = doc(db,"rooms", roomId);
  const snap = await getDoc(roomRef);
  if(!snap.exists()) throw new Error("Room not found");

  await requestFreshOffer(roomRef);
  if(myAttempt !== joinAttemptB) return;

  setStatus(callStatus, "Connecting… (requested fresh offer)");

  unsubRoomB = onSnapshot(roomRef, async (s)=>{
    if(myAttempt !== joinAttemptB) return;
    const d = s.data();
    if(!d?.offer || !d.session) return;

    if(lastAnsweredSessionB === d.session) return;

    const session = d.session;
    lastAnsweredSessionB = session;
    logDiag("New offer/session detected: " + session);

    try{
      await ensurePeer();

      const caller = collection(roomRef,"callerCandidates");
      const callee = collection(roomRef,"calleeCandidates");

      await clearSub(callee);
      if(myAttempt !== joinAttemptB) return;

      pc.onicecandidate = (e)=>{
        if(e.candidate){
          addDoc(callee, { session, ...e.candidate.toJSON() }).catch(()=>{});
        }
      };

      await pc.setRemoteDescription(d.offer);
      const ans = await pc.createAnswer();
      await pc.setLocalDescription(ans);

      await updateDoc(roomRef, { answer: ans, session, answeredAt: Date.now() });
      setStatus(callStatus, `Joined room. Connecting… (session ${session})`);
      logDiag("Answer written to room doc.");

      unsubCallerB = onSnapshot(caller, (ss)=>{
        if(myAttempt !== joinAttemptB) return;
        ss.docChanges().forEach(ch=>{
          if(ch.type !== "added" || !pc) return;
          const c = ch.doc.data();
          if(c.session !== session) return;
          try{ pc.addIceCandidate(c); }catch{}
        });
      });

      clearBRetry();
      bRetryTimer = setTimeout(async ()=>{
        if(myAttempt !== joinAttemptB) return;
        if(!pc) return;
        if(pc.connectionState === "connected") return;

        setStatus(callStatus, "Still connecting… retrying (requesting new offer)…");
        logDiag("Watchdog: requesting fresh offer again.");
        try{
          lastAnsweredSessionB = null;
          await requestFreshOffer(roomRef);
        }catch(e){ showError(e); }
      }, 10000);

      pc.onconnectionstatechange = async ()=>{
        if(myAttempt !== joinAttemptB || !pc) return;
        setStatus(callStatus, `B: ${pc.connectionState} (session ${session})`);
        if(pc.connectionState === "connected"){ clearBRetry(); }
        if(pc.connectionState === "failed" || pc.connectionState === "disconnected"){
          setStatus(callStatus, "Connection lost — requesting new offer…");
          logDiag("Connection lost => requesting fresh offer.");
          try{
            lastAnsweredSessionB = null;
            await requestFreshOffer(roomRef);
          }catch(e){ showError(e); }
        }
      };

    }catch(e){
      lastAnsweredSessionB = null;
      logDiag("Join flow error: " + (e?.message || e));
      setStatus(callStatus, "Join failed — requesting new offer…");
      try{ await requestFreshOffer(roomRef); }catch(err){ showError(err); }
    }
  });
}

/* ================== COPY INVITE ================== */
async function copyTextRobust(text){
  if(navigator.clipboard && window.isSecureContext){
    try{ await navigator.clipboard.writeText(text); return true; }catch{}
  }
  window.prompt("Copy this invite link:", text);
  return false;
}

copyLinkBtn.onclick = async ()=>{
  const roomId = roomIdInput.value.trim();
  if(!roomId) return;
  const invite = `${location.origin}${location.pathname}#${roomId}`;
  const ok = await copyTextRobust(invite);
  setStatus(callStatus, ok ? "Invite copied." : "Clipboard blocked — link shown for manual copy.");
  logDiag("Copy invite clicked.");
};

/* ================== RINGTONE ================== */
let audioCtx = null;
let ringOsc = null;
let ringGain = null;
let ringTimer = null;

function ensureAudio(){
  if(!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  return audioCtx;
}
async function unlockAudio(){
  try{
    const ctx = ensureAudio();
    if(ctx.state !== "running") await ctx.resume();
  }catch{}
}
window.addEventListener("click", ()=>{ unlockAudio(); }, { once:false, passive:true });

function startRingtone(){
  stopRingtone();
  try{
    const ctx = ensureAudio();
    if(ctx.state !== "running") ctx.resume().catch(()=>{});
    ringGain = ctx.createGain();
    ringGain.gain.value = 0.08;
    ringGain.connect(ctx.destination);

    ringOsc = ctx.createOscillator();
    ringOsc.type = "sine";
    ringOsc.frequency.value = 880;
    ringOsc.connect(ringGain);
    ringOsc.start();

    let on = true;
    ringTimer = setInterval(()=>{
      if(!ringGain) return;
      ringGain.gain.value = on ? 0.08 : 0.0001;
      on = !on;
    }, 450);

    logDiag("Ringtone started.");
  }catch(e){
    logDiag("Ringtone failed: " + (e?.message || e));
  }
}
function stopRingtone(){
  if(ringTimer){ clearInterval(ringTimer); ringTimer=null; }
  try{ if(ringOsc){ ringOsc.stop(); } }catch{}
  try{ if(ringOsc){ ringOsc.disconnect(); } }catch{}
  try{ if(ringGain){ ringGain.disconnect(); } }catch{}
  ringOsc = null;
  ringGain = null;
}

/* ================== PHONE DIRECTORY + CALLS ================== */
let myPhone = "";
let currentIncomingCall = null; // { id, data }
let currentOutgoingCallId = null;

let unsubIncoming = null;
let unsubOutgoing = null;

function stopCallListeners(){
  if(unsubIncoming){ unsubIncoming(); unsubIncoming=null; }
  if(unsubOutgoing){ unsubOutgoing(); unsubOutgoing=null; }
  currentIncomingCall = null;
  currentOutgoingCallId = null;
}

async function loadMyPhoneFromFirestore(){
  myPhone = normalizePhone(localStorage.getItem("myPhone") || "");
  myPhoneInput.value = myPhone;
  setStatus(phoneStatus, myPhone ? `Saved (local): ${myPhone}` : "Not set.");
}

async function saveMyPhone(){
  if(!requireAuthOrPrompt()) return;

  const p = normalizePhone(myPhoneInput.value);
  if(!p) throw new Error("Your phone number is empty.");
  if(!isE164(p)) throw new Error("Use E.164 format, e.g. +15551234567");

  await setDoc(doc(db, "phones", p), {
    phone: p,
    uid: myUid,
    enabled: true,
    updatedAt: serverTimestamp()
  }, { merge:true });

  myPhone = p;
  localStorage.setItem("myPhone", myPhone);

  setStatus(phoneStatus, `Saved: ${myPhone}`);
  logDiag("Saved my phone (phones directory): " + myPhone);
}

async function findUserByPhone(phone){
  const p = normalizePhone(phone);
  if(!isE164(p)) throw new Error("Callee phone must be E.164, e.g. +15557654321");

  const s = await getDoc(doc(db, "phones", p));
  if(!s.exists()) return null;

  const d = s.data() || {};
  if(d.enabled !== true) return null;

  const uid = d.uid;
  if(!uid) return null;

  return { uid, phone: p };
}

/* Prevent overwriting current incoming call */
function showIncomingUI(callId, data){
  if (unsubIncoming) { unsubIncoming(); unsubIncoming = null; }
  currentIncomingCall = { id: callId, data };
  incomingText.textContent = `Call from ${data.fromPhone || "unknown"}…`;
  incomingOverlay.style.display = "flex";
  startRingtone();
}

function stopIncomingUI(){
  incomingOverlay.style.display = "none";
  stopRingtone();
  currentIncomingCall = null;
}

async function listenIncomingCalls(){
  if(!myUid) return;

  if(unsubIncoming){ unsubIncoming(); unsubIncoming=null; }

  const qy = query(
    collection(db, "calls"),
    where("toUid", "==", myUid),
    where("status", "==", "ringing"),
    orderBy("createdAt", "desc"),
    limit(1)
  );

  unsubIncoming = onSnapshot(qy, (snap)=>{
    if(snap.empty) return;
    const d = snap.docs[0];
    const data = d.data();
    if(currentIncomingCall?.id === d.id) return;
    logDiag("Incoming call (Firestore): " + d.id);
    showIncomingUI(d.id, data);
  }, (err)=>{
    logDiag("Incoming call listener error: " + (err?.message || err));
  });
}

async function startPhoneCall(){
  if(!requireAuthOrPrompt()) return;

  myPhone = normalizePhone(myPhoneInput.value || myPhone);
  if(!myPhone){
    setStatus(phoneCallStatus, "Set and Save your phone number first.");
    return;
  }

  const calleePhone = normalizePhone(calleePhoneInput.value);
  if(!calleePhone){
    setStatus(phoneCallStatus, "Enter the other person's phone number.");
    return;
  }

  setStatus(phoneCallStatus, "Looking up user…");
  const callee = await findUserByPhone(calleePhone);
  if(!callee){
    setStatus(phoneCallStatus, "No signed-in user found with that phone number.");
    return;
  }
  if(callee.uid === myUid){
    setStatus(phoneCallStatus, "You can’t call yourself.");
    return;
  }

  setStatus(phoneCallStatus, "Creating room…");
  const created = await createRoom({ updateHash:false, reuseRoomIdInput:false, fixedRoomId:null });
  if(!created?.roomId) throw new Error("Room creation failed.");

  /* PIN room id for this phone call so restarts never jump rooms */
  pinnedRoomId = created.roomId;

  const callRef = await addDoc(collection(db,"calls"), {
    fromUid: myUid,
    toUid: callee.uid,
    fromPhone: myPhone,
    toPhone: callee.phone,
    roomId: created.roomId,
    status: "ringing",
    createdAt: serverTimestamp(),
    updatedAt: serverTimestamp()
  });

  currentOutgoingCallId = callRef.id;
  hangupBtn.disabled = false;
  callBtn.disabled = true;

  setStatus(phoneCallStatus, `Calling ${callee.phone}…`);
  logDiag(`Outgoing call created: ${callRef.id} roomId=${created.roomId}`);

  if(unsubOutgoing){ unsubOutgoing(); unsubOutgoing=null; }
  unsubOutgoing = onSnapshot(doc(db,"calls", callRef.id), (s)=>{
    if(!s.exists()) return;
    const d = s.data();
    if(!d) return;

    if(d.status === "accepted"){
      setStatus(phoneCallStatus, "Answered. Connecting…");
      logDiag("Call accepted.");
      return;
    }
    if(d.status === "declined"){
      setStatus(phoneCallStatus, "Declined.");
      logDiag("Call declined.");
      cleanupOutgoingCallUI();
      return;
    }
    if(d.status === "ended"){
      setStatus(phoneCallStatus, "Ended.");
      logDiag("Call ended.");
      cleanupOutgoingCallUI();
      return;
    }
  });
}

function cleanupOutgoingCallUI(){
  callBtn.disabled = !isAuthed;
  hangupBtn.disabled = true;
  currentOutgoingCallId = null;
  if(unsubOutgoing){ unsubOutgoing(); unsubOutgoing=null; }
  pinnedRoomId = null;
}

async function hangup(){
  if(!currentOutgoingCallId) return;
  try{
    await updateDoc(doc(db,"calls", currentOutgoingCallId), {
      status: "ended",
      updatedAt: serverTimestamp()
    });
  }catch{}
  cleanupOutgoingCallUI();
  setStatus(phoneCallStatus, "Ended.");
}

/* Answer / Decline buttons for incoming */
answerBtn.onclick = async ()=>{
  try{
    if(!currentIncomingCall) return;
    const { id, data } = currentIncomingCall;

    stopIncomingUI();

    await updateDoc(doc(db,"calls", id), { status: "accepted", updatedAt: serverTimestamp() });

    roomIdInput.value = data.roomId;
    setStatus(phoneCallStatus, `Answered ${data.fromPhone || ""}. Joining room…`);
    hangupBtn.disabled = true;
    callBtn.disabled = !isAuthed;

    await joinRoom();

    try { await listenIncomingCalls(); } catch {}
  }catch(e){
    showError(e);
  }
};

declineBtn.onclick = async ()=>{
  try{
    if(!currentIncomingCall) return;
    const { id } = currentIncomingCall;
    stopIncomingUI();
    await updateDoc(doc(db,"calls", id), { status: "declined", updatedAt: serverTimestamp() });
    setStatus(phoneCallStatus, "Declined incoming call.");
    try { await listenIncomingCalls(); } catch {}
  }catch(e){
    showError(e);
  }
};

/* ================== PUSH (optional) ================== */
let messaging = null;
let swReg = null;

async function enablePush(){
  logDiag("enablePush(): ENTER");
  logDiag("enablePush(): Notification in window=" + ("Notification" in window));
  logDiag("enablePush(): serviceWorker in navigator=" + ("serviceWorker" in navigator));
  logDiag("enablePush(): Notification.permission=" + (("Notification" in window) ? Notification.permission : "n/a"));
  logDiag("enablePush(): vapidSet=" + (!!PUBLIC_VAPID_KEY && !String(PUBLIC_VAPID_KEY).includes("PASTE_")));

  if(!requireAuthOrPrompt()) return;

  if (!("Notification" in window)) { setStatus(pushStatus, "Push: not supported in this browser."); return; }
  if (!("serviceWorker" in navigator)) { setStatus(pushStatus, "Push: service worker not supported."); return; }
  if(!PUBLIC_VAPID_KEY || PUBLIC_VAPID_KEY.includes("PASTE_")) { setStatus(pushStatus, "Push: set PUBLIC_VAPID_KEY in HTML first."); return; }

  try {
    const swUrl = new URL("firebase-messaging-sw.js", location.href);

    // PRECHECK: prove we are downloading JS and not HTML
    const resp = await fetch(swUrl, { cache: "no-store" });
    const ct = resp.headers.get("content-type") || "";
    const txt = await resp.text();
    logDiag("SW prefetch status=" + resp.status + " content-type=" + ct);
    logDiag("SW prefetch first200=" + txt.slice(0, 200).replace(/\s+/g, " "));
    if (!resp.ok) throw new Error("SW fetch failed: " + resp.status);

    swReg = await navigator.serviceWorker.register(swUrl, { scope: "./" });
    logDiag("SW registered: " + swUrl.toString());

    messaging = getMessaging(app);

    const perm = await Notification.requestPermission();
    if (perm !== "granted"){ setStatus(pushStatus, "Push: permission not granted."); return; }

    const token = await getToken(messaging, { vapidKey: PUBLIC_VAPID_KEY, serviceWorkerRegistration: swReg });
    if(!token){ setStatus(pushStatus, "Push: no token returned."); return; }

    const tokenId = token.slice(0, 32);

    await setDoc(doc(db, "users", myUid, "fcmTokens", tokenId), {
      token,
      createdAt: Date.now(),
      ua: navigator.userAgent,
      enabled: true
    }, { merge:true });

    const phone = normalizePhone(myPhoneInput.value || localStorage.getItem("myPhone") || "");
    if (isE164(phone)) {
      await setDoc(
        doc(db, "phonePushTokens", phone, "tokens", tokenId),
        { token, createdAt: Date.now(), ua: navigator.userAgent, enabled: true },
        { merge: true }
      );
      logDiag("FCM token stored for phone " + phone);
    } else {
      logDiag("FCM token NOT stored (phone missing/invalid)");
    }

    setStatus(pushStatus, "Push: enabled.");
    logDiag("FCM token stored.");

    onMessage(messaging, (payload)=>{
      logDiag("FCM foreground message: " + JSON.stringify(payload));
      const data = payload?.data || {};
      if (data.roomId) roomIdInput.value = data.roomId;

      incomingText.textContent =
        payload?.notification?.body ||
        (data.fromPhone ? `Call from ${data.fromPhone}` : "Incoming call…");

      incomingOverlay.style.display = "flex";
      startRingtone();
    });

  } catch (e) {
    setStatus(pushStatus, "Push: failed (see diagnostics).");
    logDiag("Push enable failed: " + (e?.message || e));
  }
}

/* HARD WIRING: always run push enable when the button is clicked */
enablePushBtn.addEventListener("click", (ev) => {
  ev.preventDefault();
  ev.stopPropagation();
  logDiag("Enable Push HARD listener fired");
  enablePush().catch((e) => {
    logDiag("enablePush() error: " + (e?.message || e));
    showError(e);
  });
});

/* ================== BUTTON WIRING ================== */
startBtn.onclick = async ()=>{
  try{
    hideErrorBox();
    await startMedia();
  }catch(e){
    const name = String(e?.name || "");
    if(name === "NotAllowedError" || name === "NotFoundError") return;
    showError(e);
  }
};

createBtn.onclick = ()=> createRoom({updateHash:true, reuseRoomIdInput:true, fixedRoomId:null}).catch(showError);
joinBtn.onclick   = ()=> joinRoom().catch(showError);

roomIdInput.addEventListener("input", ()=> refreshCopyInviteState());
refreshCopyInviteState();

savePhoneBtn.onclick = ()=> saveMyPhone().catch(showError);

callBtn.onclick = async () => {
  logDiag("Call button clicked");
  try { await startPhoneCall(); } catch(e){ showError(e); }
};

hangupBtn.onclick = ()=> hangup().catch(showError);

testSoundBtn.onclick = async ()=>{
  await unlockAudio();
  startRingtone();
  setTimeout(()=>stopRingtone(), 1800);
};

myPhoneInput.addEventListener("input", ()=>{
  savePhoneBtn.disabled = !isAuthed || !isE164(normalizePhone(myPhoneInput.value));
});
calleePhoneInput.addEventListener("input", refreshCallButtonState);

/* ================== AUTH STATE ================== */
onAuthStateChanged(auth, async (user)=>{
  isAuthed = !!user;
  myUid = user?.uid || null;
  logDiag(isAuthed ? "Auth: signed in" : "Auth: signed out");

  if (isAuthed){
    try{ await enforceAllowlist(user); }
    catch(e){ showError(e); return; }

    loginOverlay.style.display = "none";
    appRoot.classList.remove("locked");
    logoutBtn.style.display = "inline-block";
    loginStatus.textContent = "Signed in.";

    startBtn.disabled = false;
    setStatus(mediaStatus, "Ready. Click Start to enable camera/mic.");

    savePhoneBtn.disabled = !isE164(normalizePhone(myPhoneInput.value));
    testSoundBtn.disabled = false;
    enablePushBtn.disabled = false;

    refreshCopyInviteState();
    refreshCallButtonState();

    try{ await loadMyPhoneFromFirestore(); } catch(e){ logDiag("Load phone failed: " + (e?.message || e)); }
    try{ await listenIncomingCalls(); } catch(e){ logDiag("Incoming listener failed: " + (e?.message || e)); }

    window.addEventListener("click", () => startMedia().catch(()=>{}), { once:true });

  } else {
    loginOverlay.style.display = "flex";
    appRoot.classList.add("locked");
    logoutBtn.style.display = "none";
    stopAll();

    savePhoneBtn.disabled = true;
    callBtn.disabled = true;
    hangupBtn.disabled = true;
    testSoundBtn.disabled = true;
    enablePushBtn.disabled = true;

    setStatus(phoneStatus, "Not set.");
    setStatus(phoneCallStatus, "Idle.");
    setStatus(pushStatus, "Push: not enabled.");
  }
});

window.addEventListener("beforeunload", ()=>{
  try{ closePeer(); }catch{}
  try{ stopRingtone(); }catch{}
});
</script>
</body>
</html>
