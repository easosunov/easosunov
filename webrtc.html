<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>WebRTC</title>
 <link rel="manifest" href="manifest.json">  

<style>
body{font-family:system-ui;margin:16px} 
h1{font-size:20px;margin:0 0 10px}
.row{display:flex;gap:12px;flex-wrap:wrap}
.card{border:1px solid #ddd;border-radius:12px;padding:12px;flex:1 1 320px}
.videos{display:grid;grid-template-columns:1fr 1fr;gap:12px}
@media (max-width: 720px){ .videos{grid-template-columns:1fr} }
video {
    width: 100%;
    background: #000;
    border-radius: 12px; 
    aspect-ratio: 16/9;
    transition: all 0.3s ease;
    cursor: pointer;
}

/* Add these new classes AFTER the video selector */
video.fullscreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 9999;
    border-radius: 0;
    object-fit: contain;
}

video.small {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 200px;
    height: 150px;
    z-index: 9998;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    border: 2px solid #1976d2;
}
button{padding:10px 12px;border-radius:10px;border:1px solid #ccc;background:#f7f7f7;cursor:pointer}
button:disabled{opacity:.6;cursor:not-allowed}
input{padding:10px 12px;border-radius:10px;border:1px solid #ccc;width:100%}
.status{font-size:13px;margin-top:8px}
.small{font-size:12px;color:#555;margin-top:6px}
 
#errorBox{
  display:none;margin:12px 0;padding:10px;
  border:1px solid #f3b5b5;background:#fff5f5;
  color:#7a1b1b;border-radius:12px;white-space:pre-wrap
}

/* LOGIN OVERLAY */
#loginOverlay{
  position:fixed; inset:0; z-index:9999;
  background:rgba(0,0,0,.55);
  display:flex; align-items:center; justify-content:center;
}
#loginCard{
  width:min(520px,calc(100% - 24px));
  background:#fff; border-radius:14px;
  padding:16px;
  box-shadow:0 10px 30px rgba(0,0,0,.35);
}

/* LOGIN OVERLAY - ENLARGED FONTS */
#loginCard h2 {
  font-size: 24px !important;
  margin: 0 0 12px !important;
}

#loginCard .small {
  font-size: 16px !important;
  margin-bottom: 12px !important;
}

#loginCard label {
  font-size: 16px !important;
  display: block;
  margin-bottom: 6px;
  font-weight: 500;
}

#loginCard input {
  font-size: 18px !important;
  padding: 14px 16px !important;
  margin-bottom: 16px !important;
  border-radius: 12px !important;
}

#loginCard button {
  font-size: 18px !important;
  padding: 14px 24px !important;
  border-radius: 12px !important;
}

#loginCard #loginStatus {
  font-size: 16px !important;
  margin-top: 12px !important;
  min-height: 24px;
}

/* PHONE DIAL INTERFACE STYLES */
#dialPad {
  margin: 20px 0;
}

.dial-btn {
  font-size: 24px !important;
  padding: 20px 10px !important;
  background: #fff !important;
  border: 2px solid #1976d2 !important;
  color: #1976d2 !important;
  border-radius: 12px !important;
  min-height: 70px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
}

.dial-btn:hover {
  background: #1976d2 !important;
  color: white !important;
}

.dial-btn:active {
  transform: scale(0.95);
}

#phoneDisplay {
  font-family: monospace;
  font-weight: bold;
  user-select: none;
} 
 
#loginRow{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
#logoutBtn{float:right}
#app.locked{filter:blur(2px);opacity:.35;pointer-events:none;user-select:none}

 
/* DIAGNOSTICS */
#diagBox{
  display:none;
  margin-top:8px;
  max-height:220px;
  overflow:auto;
  background:#111;
  color:#0f0;
  padding:8px;
  border-radius:8px;
  font-size:12px;
  white-space:pre-wrap
}
.diagActions{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}

/* INCOMING CALL MODAL */
#incomingOverlay{
  position:fixed; inset:0; z-index:9998;
  background:rgba(0,0,0,.55);
  display:none; align-items:center; justify-content:center;
}
#incomingCard{
  width:min(520px,calc(100% - 24px));
  background:#fff; border-radius:14px;
  padding:16px;
  box-shadow:0 10px 30px rgba(0,0,0,.35);
}
.incomingActions{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
#answerBtn{background:#e8fff0;border-color:#bdeccc}
#declineBtn{background:#fff0f0;border-color:#f1bcbc}

/* ===== NEW: Video Quality UI ===== */
select{
  padding:10px 12px;border-radius:10px;border:1px solid #ccc;width:100%;
  background:#fff;
}
 /* ===== BOTTOM PANEL LAYOUT ===== */
.bottomPanel{
  margin-top:12px;
  border:1px solid #ddd;
  border-radius:12px;
  padding:12px;
  background:#fff;
}

.bottomGrid{
  display:grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap:12px;
}

.bottomCard{
  border:1px solid #eee;
  border-radius:12px;
  padding:12px;
  background:#fff;
}

@media (max-width: 980px){
  .bottomGrid{ grid-template-columns: 1fr 1fr; }
}
@media (max-width: 720px){
  .bottomGrid{ grid-template-columns: 1fr; }
}
/* This media query will only apply styles for mobile screens (max-width: 720px) */
@media (max-width: 720px) {
  body {
    font-size: 18px; /* Larger font size for body text */
  }

  h1 {
    font-size: 24px; /* Increase header size */
  }

  h2 {
    font-size: 20px; /* Larger sub-header size */
  }

  p, .status, .small {
    font-size: 16px; /* Increase font size for paragraphs, status text, and small text */
  }

  .button {
    font-size: 16px; /* Increase font size for buttons */
  }
}

/* Recent calls styling */
.call-item {
  padding: 6px;
  margin-bottom: 4px;
  border-radius: 6px;
  border-left: 3px solid #ccc;
  background: white;
  font-size: 11px;
  line-height: 1.3;
}
.call-incoming { border-left-color: #4CAF50; }
.call-outgoing { border-left-color: #2196F3; }
.call-missed { border-left-color: #f44336; }
.call-ended { border-left-color: #9E9E9E; }
.call-accepted { border-left-color: #8BC34A; }
.call-declined { border-left-color: #FF9800; }
.call-ringing { border-left-color: #FFC107; }
.call-item-time {
  color: #666;
  font-size: 10px;
  margin-top: 2px;
}

/* ===== NEW: Call mode radio buttons ===== */
.call-mode-options {
  display: flex;
  gap: 16px;
  margin: 8px 0;
  align-items: center;
}

.call-mode-options label {
  display: flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
}

.call-mode-options input[type="radio"] {
  margin: 0;
  cursor: pointer;
}

.call-mode-options label span {
  font-size: 14px;
}

/* ===== NEW: Button color styles ===== */
/* Active Call button - Green */
.call-btn-active {
  background-color: #4CAF50 !important; /* Green */
  color: white !important;
  border-color: #388E3C !important;
}

/* Inactive Call button against the name of callee - Red */
.call-btn-inactive-callee {
  background-color: #f44336 !important; /* Red */
  color: white !important;
  border-color: #d32f2f !important;
}

/* Inactive Call button against all other users - White */
.call-btn-inactive-other {
  background-color: white !important;
  color: #333 !important;
  border-color: #ccc !important;
}

/* Active Hang up button - Red */
.hangup-btn-active {
  background-color: #f44336 !important; /* Red */
  color: white !important;
  border-color: #d32f2f !important;
}

/* Inactive Hang up button - White */
.hangup-btn-inactive {
  background-color: white !important;
  color: #333 !important;
  border-color: #ccc !important;
}

/* Bandwidth indicator */
.bandwidth-info {
  font-size: 11px;
  color: #1976d2;
  margin-top: 4px;
  font-family: monospace;
  background: #f5f5f5;
  padding: 4px 8px;
  border-radius: 4px;
  border-left: 3px solid #1976d2;
}

/* Add to fix video quality switching issues */
video#localVideo {
  transition: opacity 0.3s ease;
}

video#localVideo.video-hidden {
  display: none !important;
}

video#localVideo.video-visible {
  display: block !important;
}

/* Quality change loading indicator */
.quality-changing {
  opacity: 0.7;
  filter: grayscale(50%);
}
 
/* Phone badge styles */
.phone-badge {
  background: #4CAF50;
  color: white;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 12px;
  margin-left: 10px;
}
.email-badge {
  background: #2196F3;
  color: white;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 12px;
  margin-left: 10px;
}
 @keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0; }
}
</style>
</head>

<body>
<h1>Telefon WebRTC</h1>

<div id="errorBox"></div>

<!-- INCOMING CALL -->
<div id="incomingOverlay">
  <div id="incomingCard">
    <h2 style="margin:0 0 8px;font-size:18px;">Incoming call</h2>
    <div id="incomingText" class="status">Someone is callingâ€¦</div>
    <div class="small">If you don't hear ringing, tap once anywhere to enable sound.</div>
    <div class="incomingActions">
      <button id="answerBtn">Answer</button>
      <button id="declineBtn">Decline</button>
    </div>
  </div>
</div>

<!-- LOGIN -->
<!-- LOGIN - PHONE DIAL INTERFACE -->
<div id="loginOverlay">
  <div id="loginCard">
    <button id="logoutBtn" style="display:none;">Logout</button>
    <h2 style="margin:0 0 20px;font-size:28px;text-align:center;">Enter Your Phone Number</h2>
    <div class="small" style="font-size:18px;text-align:center;margin-bottom:20px;">Dial your registered phone number to sign in</div>
    
    <!-- Phone number display -->
    <div id="phoneDisplay" style="font-size:32px;text-align:center;margin:20px 0;padding:15px;background:#f5f5f5;border-radius:12px;border:2px solid #ddd;min-height:60px;letter-spacing:2px;">
      
    </div>
    
    <!-- Dial pad -->
<div id="dialPad" style="display:grid;grid-template-columns:repeat(3,1fr);gap:15px;margin:20px 0;">
  <button class="dial-btn" data-number="1">1</button>
  <button class="dial-btn" data-number="2">2<div style="font-size:12px;color:#666;">ABC</div></button>
  <button class="dial-btn" data-number="3">3<div style="font-size:12px;color:#666;">DEF</div></button>
  <button class="dial-btn" data-number="4">4<div style="font-size:12px;color:#666;">GHI</div></button>
  <button class="dial-btn" data-number="5">5<div style="font-size:12px;color:#666;">JKL</div></button>
  <button class="dial-btn" data-number="6">6<div style="font-size:12px;color:#666;">MNO</div></button>
  <button class="dial-btn" data-number="7">7<div style="font-size:12px;color:#666;">PQRS</div></button>
  <button class="dial-btn" data-number="8">8<div style="font-size:12px;color:#666;">TUV</div></button>
  <button class="dial-btn" data-number="9">9<div style="font-size:12px;color:#666;">WXYZ</div></button>
  <button class="dial-btn" data-number="+">+<div style="font-size:12px;color:#666;">PLUS</div></button>
  <button class="dial-btn" data-number="0">0</button>
  <button class="dial-btn" data-number="#">#</button>
</div>
    
    <!-- Control buttons -->
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;margin:20px 0;">
      <button id="backspaceBtn" style="font-size:18px;padding:15px;background:#ffebee;border-color:#f44336;color:#c62828;">
        âŒ« Backspace
      </button>
      <button id="clearBtn" style="font-size:18px;padding:15px;background:#fff8e1;border-color:#ffc107;color:#ff8f00;">
        âœ• Clear
      </button>
    </div>
    
    <!-- Login button -->
    <button id="loginBtn" style="font-size:22px;padding:18px;background:#e8f5e9;border-color:#4caf50;color:#2e7d32;width:100%;margin:10px 0;">
      â†µ Enter / Dial to Sign In
    </button>
    
    <!-- Status display -->
    <div id="loginStatus" class="status" style="font-size:18px;text-align:center;margin:15px 0;min-height:30px;">
      Please dial your phone number
    </div>
    
    <!-- Info text -->
    <div class="small" style="font-size:16px;text-align:center;color:#666;margin-top:20px;">
      Your phone number must be registered with the administrator
    </div>
    
    <!-- Traditional login fallback -->
    <div style="margin-top:25px;border-top:1px solid #eee;padding-top:15px;">
      <button id="showEmailLoginBtn" style="font-size:16px;padding:12px;background:#f5f5f5;border-color:#ddd;color:#666;width:100%;">
        Use Email Login Instead
      </button>
    </div>
  </div>
</div>

<div id="app" class="locked">

  <!-- VIDEOS + CONTROLS UNDER EACH VIDEO (NEW LAYOUT) -->
  <div class="videos">

    <!-- LEFT: Person A video + your controls/status -->
    <div class="card">
  <b id="personATitle">Person A (You)</b>
  <video id="localVideo" autoplay muted playsinline></video>
      <div class="small">Muted so you don't hear yourself.</div>
<!-- Hang up button and call note moved to Person B section -->
     <!-- Recent calls list -->
<div style="margin-top:10px;">
  <div class="small" style="display:flex;justify-content:space-between;align-items:center;">
    <b>Recent Calls (max 30)</b>
    <button id="refreshCallsBtn" class="small" style="padding:4px 8px;font-size:11px;">Refresh</button>
  </div>
  <div id="callsList" style="margin-top:8px;max-height:200px;overflow-y:auto;border:1px solid #eee;border-radius:8px;padding:8px;font-size:12px;background:#f9f9f9;">
    <div style="color:#777;text-align:center;">No calls yet</div>
  </div>
</div>
      <hr style="border:none;border-top:1px solid #eee;margin:12px 0">
    </div>

    <!-- RIGHT: Person B video + directory list -->
    <div class="card">
  <b id="personBTitle">Person B (Other)</b>
  <video id="remoteVideo" autoplay playsinline></video>
      <div class="small">If audio doesn't play, click the video once.</div>
      <hr style="border:none;border-top:1px solid #eee;margin:12px 0">
<!-- Hang up button and call note moved here -->
<div style="margin-top:10px;display:flex;flex-direction:column;gap:10px">
  <button id="hangupBtn" disabled class="hangup-btn-inactive">Hang up</button>

  <div>
    <div class="small">Message to send with call (optional)</div>
    <input
      id="callNoteInput"
      placeholder="e.g. Let us talk at 3 pm"
      maxlength="140"
    />
    <div class="small" style="color:#777">
      This text will appear in the notification for Person B.
    </div>
  </div>
</div>

<hr style="border:none;border-top:1px solid #eee;margin:12px 0">
<div style="display:flex; justify-content:space-between; align-items:center;">
  <div class="small">All allowed users</div>
  <button id="logoutUtilityBtn" style="background:#ffebee;border-color:#f44336;color:#c62828;display:none; padding:4px 8px; font-size:11px;">
    Log Out
  </button>
</div>
<div id="usersList" style="margin-top:10px;display:flex;flex-direction:column;gap:8px"></div>
   
    </div>

  </div>

<!-- ===== BOTTOM PANEL (everything except A hangup+note and B users list) ===== -->
<div class="bottomPanel">
  <div class="bottomGrid">

    <!-- Status / Push -->
<!-- Status / Push card - find this section -->
<div class="bottomCard">
  <b>Status</b>
  <div class="status" id="myNameStatus">Not set.</div>
  <div class="status" id="pushStatus">Push: not enabled.</div>
  <div class="status" id="dirCallStatus">Idle.</div>
  <!-- ADD THIS NEW LINE -->
  <div class="status" id="mediaConnectionStatus">Media: Not connected.</div>
</div>

<!-- Add this card back - place it after the Status card -->
<div class="bottomCard">
  <b>Video quality</b>
  <!-- Updated text -->
  <div class="small">Choose before or during a call.</div>
  <select id="videoQualitySelect" disabled>
    <option value="no-video">No video (audio only)</option>
    <option value="ultra-low">Ultra Low (240p)</option>
    <option value="low">Low (360p)</option>
    <option value="medium" selected>Medium (720p)</option>
    <option value="high">High (1080p)</option>
  </select>
  <div class="status" id="videoQualityStatus">Video: Medium (720p).</div>
  <!-- NEW: Bandwidth display -->
  <div class="bandwidth-info" id="bandwidthInfo">Bandwidth: -- kbps</div>
</div>
   
  
    <!-- Profile -->
    <div class="bottomCard">
      <b>Your name</b>
      <div class="small">Shown to other users.</div>
      <input id="myNameInput" placeholder="e.g. Alex"/>
      <div style="margin-top:8px;display:flex;gap:10px;flex-wrap:wrap">
        <button id="saveNameBtn" disabled>Save Name</button>
      </div>
    </div>

    <!-- Call / Room -->
<div class="bottomCard">
  <b>Call controls</b>
  
  <div style="margin-top:8px;display:flex;gap:10px;flex-wrap:wrap">
    <button id="startBtn" disabled>Start</button>
    <button id="createBtn" disabled>Create Room</button>
    <button id="joinBtn" disabled>Join Room</button>
  </div>
  <div class="status" id="mediaStatus">Not started.</div>

  <hr style="border:none;border-top:1px solid #eee;margin:12px 0">

  <div class="small">Room ID</div>
  <input id="roomId" placeholder="Room ID"/>
  <div style="margin-top:8px;display:flex;gap:10px;flex-wrap:wrap">
    <button id="copyLinkBtn" disabled>Copy Invite</button>
  </div>

  <div class="status" id="callStatus">No room yet.</div>
  <div class="small">Invite format: <code>.../webrtc.html#ROOM_ID</code></div>
</div>

        <!-- Utilities -->
   <div class="bottomCard">
  <b>Background Notifier</b>
  <div style="margin-top:8px;display:flex;gap:10px;flex-wrap:wrap">
    <button id="startBgBtn" disabled>Start Background Service</button>
    <button id="stopBgBtn" disabled>Stop Background Service</button>
  </div>
  <div class="status" id="bgStatus">Status: Not connected</div>
  <div class="small">
    Runs in system tray to show notifications when browser is closed.<br>
    <strong>Download installer:</strong><br>
    <a href="https://github.com/easosunov/easosunov/releases/download/v1.0.0/webrtc-notifier-installer.zip" 
       id="downloadBgLink"
       target="_blank"
       download="webrtc-notifier-installer.zip"
       style="color:#1976d2; text-decoration:underline">
      webrtc-notifier-installer.zip
    </a>
  <a href="https://github.com/easosunov/webrtc-android-apk/raw/main/WebRTC_android_apk.zip" 
     target="_blank"
     style="color:#1976d2; text-decoration:underline; margin-left: 10px">
    Android WebRTC.apk
 </a>
    <div class="small" style="color:#666; margin-top:4px; font-size:11px">
  After downloading:<br>
  1. Extract the ZIP file using password<br>
  2. Windows - Run <code style="background:#f5f5f5; padding:2px 6px">webrtc-notifier-installer.exe</code><br>
  3. Windows - Look for ðŸ“ž icon in system tray<br>
4. Android - Install APK per README instructions
</div>
  </div>
</div>
   
    <div class="bottomCard">
      <b>Utilities</b>
<div style="margin-top:8px">
    <div class="small">Search users</div>
    <input id="userSearchInput" placeholder="Search usersâ€¦" />
  </div>
     
<div style="margin-top:8px;display:flex;gap:10px;flex-wrap:wrap">
    <button id="testSoundBtn" disabled>Test Ring Sound</button>
    <button id="resetPushBtn" disabled>Reset Push</button>
    <button id="refreshUsersBtn" disabled>Refresh Users</button>
    </div>
      <hr style="border:none;border-top:1px solid #eee;margin:12px 0">

      <button id="diagBtn">Diagnostics</button>
      <div class="diagActions">
        <button id="copyDiagBtn" disabled>Copy log</button>
        <button id="clearDiagBtn" disabled>Clear log</button>
      </div>
      <pre id="diagBox"></pre>
      <div class="small">Diagnostics are hidden by default. Click "Diagnostics" to show/hide.</div>
    </div>

  </div>
</div>

</div>

<script type="module">
console.log("APP VERSION:", "2026-01-03-sw-debug-ALWAYS-2");

 // Track if we showed a notification (for background app coordination)
let webPageShowedNotification = false;

// Handle notification redirects
(function handleNotificationRedirect() {
  try {
    // Check URL parameters for notification click (from background app)
    const urlParams = new URLSearchParams(window.location.search);
    const callId = urlParams.get('callId');
    const roomId = urlParams.get('roomId');
    const fromName = urlParams.get('fromName');
    const toName = urlParams.get('toName');
    const note = urlParams.get('note');
    
    // Store for later use when user signs in
    if (callId && roomId) {
      localStorage.setItem('pendingNotificationCall', JSON.stringify({
        callId: callId,
        roomId: roomId,
        fromName: fromName || 'Unknown',
        toName: toName || '',
        note: note || '',
        timestamp: Date.now()
      }));
      
      // Clear URL parameters for a clean URL
      const cleanUrl = window.location.origin + window.location.pathname;
      if (window.location.hash) {
        window.history.replaceState({}, document.title, cleanUrl + window.location.hash);
      } else {
        window.history.replaceState({}, document.title, cleanUrl);
      }
      
      console.log('Notification stored, waiting for auth...');
    }
  } catch (e) {
    console.warn('Notification redirect handler error:', e);
  }
})();

 // ===============================
// SW BOOTSTRAP (runs even when NOT logged in)
// This guarantees SW exists on both computers.
// ===============================
let swBootstrapReg = null;

async function ensureServiceWorkerInstalled() {
  if (!("serviceWorker" in navigator)) {
    console.log("[SW] not supported");
    return null;
  }

  // If already controlling the page, SW exists
  if (navigator.serviceWorker.controller) {
    console.log("[SW] controller already active");
  }

  const swUrl = new URL("/easosunov/firebase-messaging-sw.js", location.origin);
  // bump version when you change SW file
  swUrl.searchParams.set("v", "2026-01-03-bootstrap-1");

  try {
    swBootstrapReg = await navigator.serviceWorker.register(swUrl.toString(), {
      scope: "/easosunov/",
      updateViaCache: "none",
    });
    await navigator.serviceWorker.ready;
    console.log("[SW] bootstrap registered:", swBootstrapReg.scope);
    return swBootstrapReg;
  } catch (e) {
    console.error("[SW] bootstrap register failed:", e);
    return null;
  }
}

// RUN IT NOW (top-level)
await ensureServiceWorkerInstalled();

 /*const NOTIFY_CALL_URL = "https://us-central1-easosunov-webrtc.cloudfunctions.net/sendTestPush";*/
 const NOTIFY_CALL_URL = "https://us-central1-easosunov-webrtc.cloudfunctions.net/notifyIncomingCall";

/* ================== FCM PUSH TO ANDROID ================== */
async function sendFCMToAndroid(toUid, roomId, callerName, note, callId) {
  try {
    // 1. Get Android user's FCM token from Firestore
    const userDoc = await getDoc(doc(db, "users", toUid));
    if (!userDoc.exists()) {
      console.log("[FCM] Android user not found:", toUid);
      return;
    }
    
    const userData = userDoc.data();
    const fcmToken = userData?.fcmToken; // Android stores token here
    
    if (!fcmToken) {
      console.log("[FCM] No FCM token for Android user:", toUid);
      return;
    }
    
    console.log("[FCM] Sending to Android token:", fcmToken.substring(0, 20) + "...");
    
    // 2. Send FCM via your existing Cloud Function
    await fetch(NOTIFY_CALL_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        fcmToken: fcmToken,
        roomId: roomId,
        callerName: callerName,
        note: note || "",
        callId: callId,
        toUid: toUid
      })
    });
    
    console.log("[FCM] Notification sent to Android");
    
  } catch (error) {
    console.error("[FCM] Error sending to Android:", error);
  }
}
 
/* ======== CONFIG ======== */
const PUBLIC_VAPID_KEY = "BCR4B8uf0WzUuzHKlBCJO22NNnnupe88j8wkjrTwwQALDpWUeJ3umtIkNJTrLb0I_LeIeu2HyBNbogHc6Y7jNzM";
function cleanVapidKey(k){
  return String(k || "").trim().replace(/[\r\n\s]/g, "");
}
const VAPID = cleanVapidKey(PUBLIC_VAPID_KEY);

/* ================== ELEMENTS ================== */
const errorBox = document.getElementById("errorBox");

const loginOverlay = document.getElementById("loginOverlay");
const loginBtn = document.getElementById("loginBtn");
const logoutBtn = document.getElementById("logoutBtn");
const loginStatus = document.getElementById("loginStatus");
const emailInput = document.getElementById("emailInput");
const passInput = document.getElementById("passInput");
const appRoot = document.getElementById("app");
 
 /* ================== PHONE DIAL ELEMENTS ================== */
const phoneDisplay = document.getElementById("phoneDisplay");
const dialButtons = document.querySelectorAll(".dial-btn");
const backspaceBtn = document.getElementById("backspaceBtn");
const clearBtn = document.getElementById("clearBtn");
const showEmailLoginBtn = document.getElementById("showEmailLoginBtn");

let dialedNumber = ""; // Start with country code

const localVideo = document.getElementById("localVideo");
const remoteVideo = document.getElementById("remoteVideo");





 
/* ================== PHONE DIAL EVENT LISTENERS ================== */
/* ================== PHONE DIAL EVENT LISTENERS ================== */
// Initialize phone dial functionality
function initializePhoneDial() {
  console.log('=== initializePhoneDial() called ===');
  
  // Get elements fresh each time
  const dialPad = document.getElementById('dialPad');
  const phoneDisplay = document.getElementById('phoneDisplay');
  const backspaceBtn = document.getElementById('backspaceBtn');
  const clearBtn = document.getElementById('clearBtn');
  
  console.log('Elements found:', {
    dialPad: !!dialPad,
    phoneDisplay: !!phoneDisplay,
    backspaceBtn: !!backspaceBtn,
    clearBtn: !!clearBtn
  });
  
  if (!dialPad || !phoneDisplay) {
    console.error('Required elements missing!');
    return;
  }
  
  // Reset to ensure we're using the global variable
  window.dialedNumber = "";
  
// Update phone display
function updatePhoneDisplay() {
  phoneDisplay.innerHTML = window.dialedNumber + ' <span id="cursor" style="color:#1976d2;animation:blink 1s infinite">|</span>';
  console.log('Display updated:', window.dialedNumber);
}
  
  // Initialize display
  phoneDisplay.textContent = window.dialedNumber;
  console.log('Initial display set');
  
  // Clear any existing event listeners first
  const newDialPad = dialPad.cloneNode(true);
  dialPad.parentNode.replaceChild(newDialPad, dialPad);
  
  // Get fresh reference
  const freshDialPad = document.getElementById('dialPad');
  
// Use event delegation on the fresh dial pad
freshDialPad.addEventListener('click', (e) => {
  console.log('Dial pad clicked, target:', e.target);
  
  // Find the dial button that was clicked
  const dialBtn = e.target.closest('.dial-btn');
  if (dialBtn) {
    const number = dialBtn.getAttribute('data-number');
    console.log('Dial button clicked:', number);
    
    if (number) {
      window.dialedNumber += number;
      updatePhoneDisplay();
    }
  }
});
  
  // Backspace button
  if (backspaceBtn) {
    // Clone to remove old listeners
    const newBackspace = backspaceBtn.cloneNode(true);
    backspaceBtn.parentNode.replaceChild(newBackspace, backspaceBtn);
    
    // Get fresh reference and add listener
    document.getElementById('backspaceBtn').addEventListener('click', (e) => {
      e.preventDefault();
      console.log('Backspace clicked');
      
      if (window.dialedNumber.length > 0) {
        window.dialedNumber = window.dialedNumber.slice(0, -1);
        updatePhoneDisplay();
      }
    });
  }
  
  // Clear button
  if (clearBtn) {
    // Clone to remove old listeners
    const newClear = clearBtn.cloneNode(true);
    clearBtn.parentNode.replaceChild(newClear, clearBtn);
    
    // Get fresh reference and add listener
    document.getElementById('clearBtn').addEventListener('click', (e) => {
      e.preventDefault();
      console.log('Clear clicked');
      
      window.dialedNumber = "";
      updatePhoneDisplay();
    });
  }
  
// Add direct click handlers to buttons as backup
setTimeout(() => {
  const buttons = document.querySelectorAll('.dial-btn');
  console.log('Adding direct handlers to', buttons.length, 'buttons');
  
  buttons.forEach(btn => {
    const number = btn.getAttribute('data-number');
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      console.log('DIRECT: Button', number, 'clicked');
      
    if (number) {
      window.dialedNumber += number;
      updatePhoneDisplay();
    }
    });
  });
}, 100);
  
  console.log('Phone dial initialized');
}


// Initialize phone dial immediately when script loads
console.log('Script loaded, checking DOM...');

// Use setTimeout to ensure DOM is ready since we're in a module
setTimeout(() => {
  console.log('Initializing phone dial (delayed)...');
  
  // Debug: Check if dial pad elements exist
  console.log('Dial pad element:', document.getElementById('dialPad'));
  console.log('Dial buttons found:', document.querySelectorAll('.dial-btn').length);
  console.log('Phone display:', document.getElementById('phoneDisplay'));
  console.log('Backspace button:', document.getElementById('backspaceBtn'));
  console.log('Clear button:', document.getElementById('clearBtn'));
  console.log('Login button:', document.getElementById('loginBtn'));
  
  // Check if app is locked
  console.log('App root element:', appRoot);
  console.log('App locked?', appRoot?.classList?.contains('locked'));
  console.log('Login overlay display:', loginOverlay?.style?.display);
  
  // Initialize
  initializePhoneDial();
  
  // Test: Try to add a global function for testing
  window.testDialPad = function() {
    console.log('=== TESTING DIAL PAD ===');
    console.log('dialedNumber:', dialedNumber);
    console.log('phoneDisplay text:', phoneDisplay?.textContent);
    
    // Simulate a button click
    const testBtn = document.querySelector('.dial-btn[data-number="5"]');
    if (testBtn) {
      console.log('Found button 5, clicking...');
      testBtn.click();
    }
    
    return 'Test complete';
  };
  
  console.log('Test function available: window.testDialPad()');
}, 500);
 
 
/* ================== VIDEO SCREEN TOGGLE ================== */
let videoMode = {
    local: 'normal',  // 'normal', 'fullscreen', 'small'
    remote: 'normal'
};

function toggleVideoMode(videoElement, videoType) {
    const currentMode = videoMode[videoType];
    let nextMode;
    
    // Cycle through modes: normal â†’ fullscreen â†’ small â†’ normal
    if (currentMode === 'normal') {
        nextMode = 'fullscreen';
    } else if (currentMode === 'fullscreen') {
        nextMode = 'small';
    } else {
        nextMode = 'normal';
    }
    
    // Remove all mode classes
    videoElement.classList.remove('fullscreen', 'small');
    
    // Apply new mode
    if (nextMode !== 'normal') {
        videoElement.classList.add(nextMode);
    }
    
    videoMode[videoType] = nextMode;
    
    // Log for debugging
    logDiag(`Video ${videoType} mode: ${currentMode} â†’ ${nextMode}`);
    
    // If other video is in fullscreen, put it in small mode
    const otherVideo = videoType === 'local' ? remoteVideo : localVideo;
    const otherType = videoType === 'local' ? 'remote' : 'local';
    
    if (otherVideo.classList.contains('fullscreen')) {
        otherVideo.classList.remove('fullscreen');
        otherVideo.classList.add('small');
        videoMode[otherType] = 'small';
        logDiag(`Other video ${otherType} downgraded to small mode`);
    }
}

// Add click event listeners
localVideo.addEventListener('click', () => {
    toggleVideoMode(localVideo, 'local');
});

remoteVideo.addEventListener('click', () => {
    toggleVideoMode(remoteVideo, 'remote');
});

// Also allow double-click for direct fullscreen
localVideo.addEventListener('dblclick', () => {
    if (videoMode.local !== 'fullscreen') {
        localVideo.classList.remove('small');
        localVideo.classList.add('fullscreen');
        videoMode.local = 'fullscreen';
        
        // If remote is fullscreen, make it small
        if (remoteVideo.classList.contains('fullscreen')) {
            remoteVideo.classList.remove('fullscreen');
            remoteVideo.classList.add('small');
            videoMode.remote = 'small';
        }
    }
});

remoteVideo.addEventListener('dblclick', () => {
    if (videoMode.remote !== 'fullscreen') {
        remoteVideo.classList.remove('small');
        remoteVideo.classList.add('fullscreen');
        videoMode.remote = 'fullscreen';
        
        // If local is fullscreen, make it small
        if (localVideo.classList.contains('fullscreen')) {
            localVideo.classList.remove('fullscreen');
            localVideo.classList.add('small');
            videoMode.local = 'small';
        }
    }
});

// Exit fullscreen on Escape key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        if (localVideo.classList.contains('fullscreen')) {
            localVideo.classList.remove('fullscreen');
            localVideo.classList.add('small');
            videoMode.local = 'small';
        }
        if (remoteVideo.classList.contains('fullscreen')) {
            remoteVideo.classList.remove('fullscreen');
            remoteVideo.classList.add('small');
            videoMode.remote = 'small';
        }
    }
});
const startBtn = document.getElementById("startBtn");
const createBtn= document.getElementById("createBtn");
const joinBtn  = document.getElementById("joinBtn");
const copyLinkBtn = document.getElementById("copyLinkBtn");
const roomIdInput = document.getElementById("roomId");
const mediaStatus = document.getElementById("mediaStatus");
const callStatus  = document.getElementById("callStatus");

const diagBtn = document.getElementById("diagBtn");
const diagBox = document.getElementById("diagBox");
const copyDiagBtn = document.getElementById("copyDiagBtn");
const clearDiagBtn = document.getElementById("clearDiagBtn");

/* Incoming modal */
const incomingOverlay = document.getElementById("incomingOverlay");
const incomingText = document.getElementById("incomingText");
const answerBtn = document.getElementById("answerBtn");
const declineBtn = document.getElementById("declineBtn");

/* Directory UI (C-lite) */
const myNameInput = document.getElementById("myNameInput");
const saveNameBtn = document.getElementById("saveNameBtn");
const refreshUsersBtn = document.getElementById("refreshUsersBtn");
const myNameStatus = document.getElementById("myNameStatus");
const userSearchInput = document.getElementById("userSearchInput");
const usersList = document.getElementById("usersList");
const dirCallStatus = document.getElementById("dirCallStatus");

/* Calls list UI */
const callsList = document.getElementById("callsList");
const refreshCallsBtn = document.getElementById("refreshCallsBtn");
 
/* Push + sound + hangup */
const pushStatus = document.getElementById("pushStatus");
const testSoundBtn = document.getElementById("testSoundBtn");
const hangupBtn = document.getElementById("hangupBtn");
const resetPushBtn = document.getElementById("resetPushBtn");
const callNoteInput = document.getElementById("callNoteInput");

/* ===== NEW: video quality UI elements ===== */
const videoQualitySelect = document.getElementById("videoQualitySelect");
const videoQualityStatus = document.getElementById("videoQualityStatus");
const bandwidthInfo = document.getElementById("bandwidthInfo"); // NEW: bandwidth display

// Background service elements
const startBgBtn = document.getElementById('startBgBtn');
const stopBgBtn = document.getElementById('stopBgBtn');
const bgStatus = document.getElementById('bgStatus');
const downloadBgLink = document.getElementById('downloadBgLink');

const logoutUtilityBtn = document.getElementById("logoutUtilityBtn");

/* ================== PHONE AUTHENTICATION VARIABLES ================== */
let isAutoLoginAttempted = false;
let isAndroidPhoneLogin = false;
let userPhone = '';
 
/* ================== STATE VARIABLES ================== */
let isAuthed = false;
let myUid = null;
let wasManualLogin = false;
let pendingIncomingCallWhileLoggedOut = null;
// Set initial state to hide login overlay until auth check completes
loginOverlay.style.display = "flex";
appRoot.classList.add("locked");

let isInCall = false;
let currentCalleeUid = null; // Track who we're calling (or who called us)

// NEW: Bandwidth monitoring
let bandwidthCheckInterval = null;
let lastBandwidth = null;
 
const setStatus = (el,msg)=> el.textContent = msg;
 
 function updateMediaConnectionStatus(status) {
  const el = document.getElementById("mediaConnectionStatus");
  if (el) el.textContent = "Media: " + status;
}
 
async function notifyCall(callId){
  try{
    if(!callId) throw new Error("notifyCall: missing callId");

    const url = new URL(NOTIFY_CALL_URL);
    url.searchParams.set("callId", callId);

    logDiag("notifyCall: calling " + url.toString());
    const r = await fetch(url.toString(), { method: "GET" });

    const text = await r.text().catch(()=> "");
    logDiag(`notifyCall: status=${r.status} body=${text.slice(0, 200)}`);
  }catch(e){
    logDiag("notifyCall ERROR: " + (e?.message || e));
  }
}

/* ================== DIAGNOSTICS ================== */
let diagVisible = false;
const diagLog = [];
function logDiag(msg){
  const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
  diagLog.push(line);
  console.log(line);
  if (diagVisible) {
    diagBox.textContent = diagLog.join("\n");
    diagBox.scrollTop = diagBox.scrollHeight;
  }
  copyDiagBtn.disabled = diagLog.length === 0;
  clearDiagBtn.disabled = diagLog.length === 0;
}
diagBtn.onclick = () => {
  diagVisible = !diagVisible;
  diagBox.style.display = diagVisible ? "block" : "none";
  diagBtn.textContent = diagVisible ? "Hide diagnostics" : "Diagnostics";
  if (diagVisible) {
    diagBox.textContent = diagLog.join("\n");
    diagBox.scrollTop = diagBox.scrollHeight;
  }
};
clearDiagBtn.onclick = () => {
  diagLog.length = 0;
  if (diagVisible) diagBox.textContent = "";
  copyDiagBtn.disabled = true;
  clearDiagBtn.disabled = true;
  logDiag("Diagnostics cleared.");
};
copyDiagBtn.onclick = async () => {
  const text = diagLog.join("\n");
  if (!text) return;
  try{
    await navigator.clipboard.writeText(text);
    logDiag("Copied diagnostics to clipboard.");
  }catch{
    window.prompt("Copy diagnostics:", text);
  }
};

/* ================== ERROR HANDLING ================== */
function showError(e){
  const code = e?.code ? `\ncode: ${e.code}` : "";
  const msg  = e?.message ? `\nmessage: ${e.message}` : "";
  errorBox.style.display = "block";
  errorBox.textContent = `${String(e?.stack || "")}${code}${msg}`.trim() || String(e);
  logDiag("ERROR: " + String(e?.code || "") + " :: " + String(e?.message || e));
}
function hideErrorBox(){
  errorBox.style.display = "none";
  errorBox.textContent = "";
}
window.addEventListener("error", (e)=> showError(e.error || e.message || e));
window.addEventListener("unhandledrejection", (e)=> showError(e.reason || e));
emailInput?.addEventListener("input", () => { hideErrorBox(); if(loginStatus) loginStatus.textContent=""; });
passInput?.addEventListener("input", () => { hideErrorBox(); if(loginStatus) loginStatus.textContent=""; });

/* ================== FIREBASE ================== */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
import {
  getFirestore, doc, collection, addDoc, setDoc, getDoc, updateDoc,
  onSnapshot, getDocs, writeBatch, query, where, limit, orderBy, serverTimestamp,
  documentId, deleteDoc, or
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

import { getMessaging, getToken, onMessage, deleteToken }
  from "https://www.gstatic.com/firebasejs/10.12.5/firebase-messaging.js";

import {
  getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut,
  setPersistence, inMemoryPersistence, signInWithCustomToken
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";

const app = initializeApp({
  apiKey:"AIzaSyAg6TXwgejbPAyuEPEBqW9eHaZyLV4Wq98",
  authDomain:"easosunov-webrtc.firebaseapp.com",
  projectId:"easosunov-webrtc",
  storageBucket:"easosunov-webrtc.firebasestorage.app",
  messagingSenderId:"100169991412",
  appId:"1:100169991412:web:27ef6820f9a59add6b4aa1"
});
const db = getFirestore(app);
const auth = getAuth(app);

/* ================== PHONE NUMBER AUTHENTICATION ================== */
// Platform detection
function isAndroidDevice() {
  return /android/i.test(navigator.userAgent);
}

// Get phone number from URL parameters (sent by Android APK)
function getPhoneNumberFromURL() {
  const urlParams = new URLSearchParams(window.location.search);
  const phone = urlParams.get('phone');
  return phone ? phone.replace(/[^0-9+]/g, '') : null;
}


// Check if phone number exists in the system
async function isPhoneNumberAllowed(phoneNumber) {
  try {
    console.log("isPhoneNumberAllowed called with:", phoneNumber);
    
    if (!phoneNumber || phoneNumber === "") {
      return { allowed: false, message: "Please enter a valid phone number" };
    }
    
    // Normalize phone number format (E.164 format: +12345678901)
    const normalizedPhone = phoneNumber.replace(/[^\d+]/g, '');
    
    console.log("Checking normalized phone:", normalizedPhone);
    
    // Check if this looks like a valid phone number
    if (!normalizedPhone.startsWith('+') || normalizedPhone.replace('+', '').length < 10) {
      return { 
        allowed: false, 
        message: "Please enter a valid phone number with country code (format: +12345678901)" 
      };
    }
    
    // Check if phone number exists in phones collection
const phoneLookupRef = doc(db, "phones", normalizedPhone);
const phoneLookupSnap = await getDoc(phoneLookupRef);
    
    if (!phoneLookupSnap.exists()) {
      return { 
        allowed: false, 
        message: "Phone number not registered in system" 
      };
    }
    
    const phoneData = phoneLookupSnap.data();
    const userId = phoneData.uid;
    
    if (!userId) {
      return { 
        allowed: false, 
        message: "Phone number mapping incomplete" 
      };
    }
    
    // Get user details from users collection
    const userRef = doc(db, "users", userId);
    const userSnap = await getDoc(userRef);
    
    if (!userSnap.exists()) {
      return { 
        allowed: false, 
        message: "User account not found" 
      };
    }
    
    const userData = userSnap.data();
    
    console.log("Found user for phone:", {
      phone: normalizedPhone,
      uid: userId,
      userData: userData
    });
    
    return { 
      allowed: true,
      message: "Phone number verified",
      uid: userId,
      displayName: userData.displayName || "User " + normalizedPhone.slice(-4),
      email: userData.email || "",
      phoneNumber: normalizedPhone
    };
    
  } catch (error) {
    console.error("Error checking phone number:", error);
    
    if (error.code === 'permission-denied') {
      return { 
        allowed: false, 
        message: "Database permission error. Please contact administrator." 
      };
    }
    
    return { 
      allowed: false, 
      message: "Error checking phone number: " + error.message 
    };
  }
}

// Phone number auto-login for Android
async function attemptPhoneNumberAutoLogin() {
  if (!isAndroidDevice() || isAutoLoginAttempted) return;
  
  isAutoLoginAttempted = true;
  const phoneNumber = getPhoneNumberFromURL();
  
  if (!phoneNumber) {
    console.log("No phone number detected in URL");
    return;
  }
  
  console.log("Detected phone number:", phoneNumber);
  logDiag("Detected Android device. Attempting phone number login...");
  
  // Check if phone number is allowed
  const phoneCheck = await isPhoneNumberAllowed(phoneNumber);
  
  if (!phoneCheck.allowed) {
    console.log("Phone number not found in allowlist");
    logDiag("Phone number not registered. Please use email login.");
    return;
  }
  
  // Phone number is allowed - attempt authentication
  try {
    logDiag(`Phone login authorized for: ${phoneCheck.displayName}`);
    
    // Store phone number info globally
    userPhone = phoneNumber;
    isAndroidPhoneLogin = true;
    
    // For now, we'll set a flag and let the normal auth flow continue
    // In the auth state listener, we'll handle this specially
    
  } catch (error) {
    console.error("Phone auto-login error:", error);
    logDiag("Auto-login failed: " + error.message);
    isAndroidPhoneLogin = false;
  }
}

// Direct phone number authentication (for dial interface)
async function authenticateWithPhoneNumber(phoneNumber) {
  try {
    logDiag(`Attempting direct phone auth for: ${phoneNumber}`);
    
    // Check if phone number is allowed
    const phoneCheck = await isPhoneNumberAllowed(phoneNumber);
    
    if (!phoneCheck.allowed) {
      return { 
        success: false, 
        message: "Phone number not registered",
        requiresEmail: false 
      };
    }
    
    // If we have an email, we need password for Firebase Auth
    // For now, we'll use a custom token approach or direct Firestore verification
    // This is a simplified approach - in production, you'd use Firebase Custom Auth
    
    // For this demo, we'll simulate authentication by setting global state
    // and letting the user in (if they have email/password, we'll ask for it)
    
    if (phoneCheck.email) {
      return {
        success: true,
        message: "Phone verified",
        requiresEmail: true,
        email: phoneCheck.email,
        uid: phoneCheck.uid,
        displayName: phoneCheck.displayName
      };
    } else {
      // No email associated - can't use Firebase Auth directly
      return {
        success: false,
        message: "No email associated with this phone number",
        requiresEmail: false
      };
    }
    
  } catch (error) {
    logDiag("Phone authentication error: " + error.message);
    return {
      success: false,
      message: "Authentication error: " + error.message,
      requiresEmail: false
    };
  }
}

// Phone authentication using existing Firebase users
async function signInWithPhoneNumber(phoneNumber) {
  try {
    logDiag(`Attempting phone auth for: ${phoneNumber}`);
    
    // First verify the phone number is in the system
    const phoneCheck = await isPhoneNumberAllowed(phoneNumber);
    
    if (!phoneCheck.allowed) {
      return { 
        success: false, 
        message: phoneCheck.message || "Phone number not registered"
      };
    }
    
    // Check if we have an email for this user
    if (!phoneCheck.email) {
      return {
        success: false,
        message: "No email associated with this phone number",
        requiresEmail: false
      };
    }
    
    // Since users were created with email/password, we need their actual password
    // We can't retrieve passwords from Firebase, so we need to ask the user
    logDiag(`Phone verified. User email: ${phoneCheck.email}`);
    
    // Show email login form for user to enter their actual password
    return {
      success: false,
      message: "Please enter your password",
      requiresEmail: true,
      email: phoneCheck.email,
      uid: phoneCheck.uid,
      displayName: phoneCheck.displayName
    };
    
  } catch (error) {
    logDiag("Phone authentication error: " + error.message);
    return {
      success: false,
      message: "Authentication error: " + error.message,
      requiresEmail: false
    };
  }
}
 
// Handle Android phone authentication
async function handleAndroidPhoneAuthentication() {
  try {
    const phoneNumber = userPhone;
    if (!phoneNumber) {
      showLoginUI();
      return;
    }
    
    logDiag("Verifying phone number...");
    
    // Check phone number again
    const phoneCheck = await isPhoneNumberAllowed(phoneNumber);
    
    if (!phoneCheck.allowed) {
      logDiag("Phone number not registered");
      showLoginUI();
      return;
    }
    
    // If we have an email associated with the phone, try to pre-fill it
    if (phoneCheck.email) {
      logDiag(`Attempting email login for Android user: ${phoneCheck.email}`);
      // We'll show the email login form with pre-filled email
      showEmailLoginForm(phoneCheck.email, phoneNumber);
    } else {
      // No email associated - show standard login
      showLoginUI();
    }
    
  } catch (error) {
    console.error("Android phone auth error:", error);
    logDiag("Phone authentication failed: " + error.message);
    showLoginUI();
  }
}

// Show login UI with optional pre-filled email
function showLoginUI() {
  loginOverlay.style.display = "flex";
  appRoot.classList.add("locked");
}

// Show email login form with pre-filled email
function showEmailLoginForm(email, phoneNumber) {
  if (!document.querySelector('#loginCard')) return;
  
  document.querySelector('#loginCard').innerHTML = `
    <button id="logoutBtn" style="display:none;">Logout</button>
    <h2 style="margin:0 0 20px;font-size:28px;text-align:center;">Enter Password</h2>
    <div class="small" style="font-size:18px;text-align:center;margin-bottom:20px;">
      Phone: <strong>${phoneNumber || ''}</strong><br>
      Email: <strong>${email || ''}</strong>
    </div>
    
    <div style="margin:20px 0;">
      <div style="font-size:20px;margin-bottom:8px;font-weight:bold;">Email (read-only)</div>
      <input id="emailInput" type="email" value="${email || ''}" readonly style="font-size:20px;padding:16px;width:100%;background:#f5f5f5;border-radius:12px;"/>
    </div>
    
    <div style="margin:20px 0;">
      <div style="font-size:20px;margin-bottom:8px;font-weight:bold;">Password</div>
      <input id="passInput" type="password" placeholder="Enter your password" autocomplete="current-password" style="font-size:20px;padding:16px;width:100%;border-radius:12px;border:2px solid #1976d2;"/>
    </div>
    
    <button id="loginBtn" style="font-size:22px;padding:18px;background:#4caf50;color:white;border:none;border-radius:12px;width:100%;margin:10px 0;cursor:pointer;">
      Sign In
    </button>
    
    <div id="loginStatus" style="font-size:18px;text-align:center;margin:20px 0;min-height:30px;color:#666;">
      Enter password for ${email || ''}
    </div>
    
    <div style="margin-top:25px;border-top:1px solid #eee;padding-top:20px;">
      <button id="showPhoneLoginBtn" style="font-size:18px;padding:14px;background:#f5f5f5;border:2px solid #ddd;color:#666;width:100%;border-radius:12px;cursor:pointer;">
        â† Use Different Phone Number
      </button>
    </div>
  `;
  
  // Re-attach event listeners
  setTimeout(() => {
    const showPhoneLoginBtn = document.getElementById('showPhoneLoginBtn');
    const loginBtn = document.getElementById('loginBtn');
    const passInput = document.getElementById('passInput');
    
    if (showPhoneLoginBtn) {
      showPhoneLoginBtn.addEventListener('click', () => {
        location.reload();
      });
    }
    
    if (loginBtn) {
      loginBtn.addEventListener('click', handleEmailLogin);
    }
    
    if (passInput) {
      passInput.focus();
    }
  }, 100);
}

// Handle email login
async function handleEmailLogin() {
  const emailInput = document.getElementById('emailInput');
  const passInput = document.getElementById('passInput');
  const loginStatus = document.getElementById('loginStatus');
  
  if (!emailInput || !passInput || !loginStatus) return;
  
  const email = emailInput.value.trim();
  const password = passInput.value;
  
  if (!email || !password) {
    loginStatus.textContent = "Please enter email and password";
    return;
  }
  
  loginStatus.textContent = "Signing in...";
  
  try {
    await signInWithEmailAndPassword(auth, email, password);
    loginStatus.textContent = "Signed in successfully!";
  } catch (error) {
    loginStatus.textContent = `Login failed: ${error.code || "unknown error"}`;
    logDiag("Email login error: " + error.message);
  }
}

/* ================== PROCESS PENDING NOTIFICATIONS ================== */
// Process pending notifications after authentication
async function processPendingNotifications() {
  try {
    const pending = localStorage.getItem('pendingNotificationCall');
    if (pending) {
      try {
        const pendingData = JSON.parse(pending);
        // If notification is less than 60 seconds old
        if (Date.now() - pendingData.timestamp < 60000) {
          if (isAuthed && myUid) {
            showIncomingUI(pendingData.callId, {
              roomId: pendingData.roomId,
              fromName: pendingData.fromName || 'Unknown',
              toName: pendingData.toName || '',
              note: pendingData.note || ''
            });
          }
        }
        // Clear after processing
        localStorage.removeItem('pendingNotificationCall');
      } catch (e) {
        localStorage.removeItem('pendingNotificationCall');
      }
    }
  } catch (e) {
    console.warn('processPendingNotifications error:', e);
  }
}

/* ================== URL OPEN (from push click) ================== */
(function handlePushOpen(){
  try{
    const qs = new URLSearchParams(location.search);
    const callId = qs.get("callId");
    const roomId = qs.get("roomId");
    const fromName = qs.get("fromName");
    const toName = qs.get("toName");

    if(callId && roomId){
      incomingText.textContent = `Call from ${fromName || "unknown"}â€¦`;
      incomingOverlay.style.display = "flex";
      if (typeof startRingtone === "function") startRingtone();

      pendingIncomingCallWhileLoggedOut = {
        id: callId,
        data: { roomId, fromName, toName }
      };

      roomIdInput.value = roomId;
    }
  }catch(e){
    console.warn("Push open parse failed", e);
  }
})();

/* ================== URL HASH / AUTOJOIN MODE ================== */
const openedFromInvite = (location.hash.length > 1);
let suppressAutoJoin = false;

// NEW: If opened from Android notification (has query params), suppress auto-join
const urlParams = new URLSearchParams(window.location.search);
if (urlParams.has('callId') || urlParams.has('roomId')) {
  suppressAutoJoin = true;
  logDiag("Android notification detected - suppressing auto-join");
}

/* ================== WEBRTC ================== */
let rtcConfig = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

async function loadIceServers() {
  logDiag("Fetching ICE servers â€¦");
  const r = await fetch("https://turn-token.easosunov.workers.dev/ice");
  if (!r.ok) throw new Error("ICE fetch failed: " + r.status);
  const data = await r.json();
  rtcConfig = { iceServers: data.iceServers };
  logDiag("ICE servers detail (urls only): " + JSON.stringify(
    (data.iceServers || []).map(s => ({ urls: s.urls }))
  ));
  logDiag("ICE servers loaded: " + (data.iceServers?.length || 0));
}

let localStream = null;
let pc = null;

/* ===== NEW: Video quality profiles =====
   Low:    640x360 @ 15fps
   Medium: 1280x720 @ 30fps
   High:   1920x1080 @ 30fps
*/
const VIDEO_PROFILES = {
  'no-video':   { label: "Audio only",   constraints: false }, // false = no video track
  'ultra-low':  { label: "Ultra Low (240p)", constraints: { width:{ideal:424, max:424}, height:{ideal:240, max:240}, frameRate:{ideal:10, max:10} } },
  'low':        { label: "Low (360p)",    constraints: { width:{ideal:640, max:640}, height:{ideal:360, max:360}, frameRate:{ideal:15, max:15} } },
  'medium':     { label: "Medium (720p)", constraints: { width:{ideal:1280, max:1280}, height:{ideal:720, max:720}, frameRate:{ideal:30, max:30} } },
  'high':       { label: "High (1080p)",  constraints: { width:{ideal:1920, max:1920}, height:{ideal:1080, max:1080}, frameRate:{ideal:30, max:30} } },
};
 
// Persist selection
const LS_VIDEO_QUALITY = "webrtc_video_quality";
function getSavedVideoQuality(){
  try{
    const v = String(localStorage.getItem(LS_VIDEO_QUALITY) || "").trim();
    return (v && VIDEO_PROFILES[v]) ? v : "medium";
  }catch{
    return "medium";
  }
}
function saveVideoQuality(v){
  try{ localStorage.setItem(LS_VIDEO_QUALITY, String(v||"")); }catch{}
}

let selectedVideoQuality = getSavedVideoQuality();

function updateVideoQualityUi(){
  if(videoQualitySelect){  // <-- FIX: Use the correct element name
    videoQualitySelect.value = selectedVideoQuality;
  }
  const label = VIDEO_PROFILES[selectedVideoQuality]?.label || "Medium (720p)";
  if(videoQualityStatus) {
    if (selectedVideoQuality === 'no-video') {
      videoQualityStatus.textContent = "Audio only";
    } else {
      videoQualityStatus.textContent = `Video: ${label}.`;
    }
  }
}

updateVideoQualityUi();

// ===== NEW: Enhanced video quality change handler =====
// ===== FIXED: Video quality change handler =====
videoQualitySelect?.addEventListener("change", async () => {
  const newQuality = String(videoQualitySelect.value || "medium");
  
  // Don't do anything if quality didn't change
  if (newQuality === selectedVideoQuality) return;
  
  // Save old quality in case we need to revert
  const oldQuality = selectedVideoQuality;
  
  // Update UI immediately
  selectedVideoQuality = newQuality;
  saveVideoQuality(selectedVideoQuality);
  updateVideoQualityUi();
  
  // Show loading state
  const originalStatus = videoQualityStatus.textContent;
  videoQualityStatus.textContent = "Changing...";
  
  try {
    // Apply the quality change
    await applyVideoQualityToCurrentStream(selectedVideoQuality);
    
    // Update status with new quality
    const label = VIDEO_PROFILES[selectedVideoQuality]?.label || "Medium (720p)";
    if (selectedVideoQuality === 'no-video') {
      videoQualityStatus.textContent = "Audio only";
    } else {
      videoQualityStatus.textContent = `Video: ${label}`;
    }
    
    logDiag(`Quality changed to: ${selectedVideoQuality}`);
    
  } catch (error) {
    logDiag("Failed to change quality: " + error.message);
    
    // Revert UI on error
    selectedVideoQuality = oldQuality;
    updateVideoQualityUi();
    
    videoQualityStatus.textContent = "Failed to change";
    setTimeout(() => {
      const label = VIDEO_PROFILES[selectedVideoQuality]?.label || "Medium (720p)";
      if (selectedVideoQuality === 'no-video') {
        videoQualityStatus.textContent = "Audio only";
      } else {
        videoQualityStatus.textContent = `Video: ${label}`;
      }
    }, 2000);
  }
});


/* ===== FIXED: applyVideoQualityToCurrentStream - Working version ===== */
async function applyVideoQualityToCurrentStream(quality) {
  const profile = VIDEO_PROFILES[quality] || VIDEO_PROFILES.medium;
  
  // Get current state
  const hasVideoTrack = localStream?.getVideoTracks?.().length > 0;
  const hasAudioTrack = localStream?.getAudioTracks?.().length > 0;
  
  logDiag(`applyVideoQualityToCurrentStream: ${quality}, hasVideo: ${hasVideoTrack}, hasAudio: ${hasAudioTrack}`);
  
  // CASE 1: Switching TO audio-only (no video)
  if (quality === 'no-video') {
    if (hasVideoTrack) {
      logDiag("Switching to audio-only mode");
      
      // Get and stop all video tracks
      const videoTracks = localStream.getVideoTracks();
      videoTracks.forEach(track => {
        track.stop();
        localStream.removeTrack(track);
      });
      
      // Update peer connection if in call
      if (pc && isInCall) {
        const senders = pc.getSenders();
        senders.forEach(sender => {
          if (sender.track && sender.track.kind === 'video') {
            logDiag("Removing video track from peer connection sender");
            sender.replaceTrack(null).catch(e => {
              logDiag("Error removing video track: " + e.message);
            });
          }
        });
      }
      
      // Hide and clear local video
      localVideo.classList.remove('video-visible');
      localVideo.classList.add('video-hidden');
      localVideo.srcObject = null;
      
      logDiag("Successfully switched to audio-only");
    }
    return;
  }
  
  // CASE 2: We need video (either adding or changing quality)
  logDiag(`Setting video quality to: ${quality}`);
  
  try {
    // Step 1: Stop any existing video track
    if (hasVideoTrack) {
      const oldVideoTracks = localStream.getVideoTracks();
      oldVideoTracks.forEach(track => {
        track.stop();
        localStream.removeTrack(track);
      });
      
      // Also remove from peer connection
      if (pc && isInCall) {
        const senders = pc.getSenders();
        senders.forEach(sender => {
          if (sender.track && sender.track.kind === 'video') {
            sender.replaceTrack(null).catch(e => {
              logDiag("Error clearing old video track: " + e.message);
            });
          }
        });
      }
    }
    
    // Step 2: Get new video track with desired quality
    logDiag("Requesting new video track with constraints:", profile.constraints);
    
    const constraints = {
      video: profile.constraints,
      audio: hasAudioTrack ? false : true // Only request audio if we don't have it
    };
    
    const newStream = await navigator.mediaDevices.getUserMedia(constraints);
    const newVideoTrack = newStream.getVideoTracks()[0];
    
    if (!newVideoTrack) {
      throw new Error("No video track returned from getUserMedia");
    }
    
    // Step 3: Add audio track if needed
    if (!hasAudioTrack && newStream.getAudioTracks().length > 0) {
      const audioTrack = newStream.getAudioTracks()[0];
      localStream.addTrack(audioTrack);
      logDiag("Added audio track from new stream");
    }
    
    // Step 4: Add video track to local stream
    localStream.addTrack(newVideoTrack);
    localVideo.srcObject = localStream;
    
    // Show video
    localVideo.classList.remove('video-hidden');
    localVideo.classList.add('video-visible');
    
    // Step 5: Update peer connection
    if (pc && isInCall) {
      const senders = pc.getSenders();
      const videoSender = senders.find(s => s.track?.kind === 'video' || !s.track);
      
      if (videoSender) {
        logDiag("Replacing track in existing video sender");
        await videoSender.replaceTrack(newVideoTrack);
      } else {
        logDiag("Adding new video sender to peer connection");
        pc.addTrack(newVideoTrack, localStream);
      }
      
      // Also update audio if needed
      if (!hasAudioTrack) {
        const audioSender = senders.find(s => s.track?.kind === 'audio');
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioSender && audioTrack) {
          await audioSender.replaceTrack(audioTrack);
        }
      }
    }
    
    logDiag(`Successfully applied video quality: ${quality}`);
    
    // Verify the track is working
    setTimeout(() => {
      const currentVideoTrack = localStream.getVideoTracks()[0];
      if (currentVideoTrack) {
        const settings = currentVideoTrack.getSettings();
        logDiag("Video track settings:", {
          width: settings.width,
          height: settings.height,
          frameRate: settings.frameRate,
          readyState: currentVideoTrack.readyState
        });
      }
    }, 500);
    
  } catch (error) {
    logDiag("Failed to apply video quality: " + error.message);
    
    // If we failed to get video, revert to audio-only
    if (quality !== 'no-video') {
      logDiag("Reverting to audio-only due to error");
      selectedVideoQuality = 'no-video';
      updateVideoQualityUi();
      
      // Hide video
      localVideo.classList.remove('video-visible');
      localVideo.classList.add('video-hidden');
      localVideo.srcObject = null;
    }
    
    throw error;
  }
}


/* for call sessions, pin the room id so restarts never jump rooms */
let pinnedRoomId = null;

function closePeer(){
  if(pc){
    pc.onicecandidate=null;
    pc.ontrack=null;
    pc.onconnectionstatechange=null;
    pc.oniceconnectionstatechange=null;
    try{ pc.close(); }catch{}
    pc=null;
  }
  remoteVideo.srcObject = null;
}

async function ensurePeer() {
  closePeer();

  if (!rtcConfig || !rtcConfig.iceServers || rtcConfig.iceServers.length === 0) {
    await loadIceServers();
  }

  pc = new RTCPeerConnection(rtcConfig);
  logDiag("Created RTCPeerConnection with ICE servers");

  const rs = new MediaStream();
  remoteVideo.srcObject = rs;

  pc.ontrack = (e) => {
    e.streams[0].getTracks().forEach(t => rs.addTrack(t));
    remoteVideo.muted = false;
    remoteVideo.play().catch(() => {});
    logDiag(`ontrack: ${e.streams[0].getTracks().map(t=>t.kind).join(",")}`);
    updateMediaConnectionStatus("Connected âœ“");
    // Start bandwidth monitoring when media starts flowing
    startBandwidthMonitoring();
  };

  // ===== FIXED: Enhanced connection state handler =====
  pc.onconnectionstatechange = () => { 
    if (pc) {
      logDiag("pc.connectionState=" + pc.connectionState);
      
      if (pc.connectionState === "connected") {
        updateMediaConnectionStatus("Connected âœ“");
        // Update dirCallStatus when connected
        setStatus(dirCallStatus, "Answered. Connected.");
        // Stop listening to Firestore updates when connected
        if (unsubCallDoc) {
          unsubCallDoc();
          unsubCallDoc = null;
        }
        // Start bandwidth monitoring
        startBandwidthMonitoring();
      } else if (pc.connectionState === "disconnected" || pc.connectionState === "failed") {
        updateMediaConnectionStatus("Disconnected");
        // Stop bandwidth monitoring
        stopBandwidthMonitoring();
        updateBandwidthDisplay(null);
      }
    }
  };
 
  pc.oniceconnectionstatechange = () => { if (pc) logDiag("pc.iceConnectionState=" + pc.iceConnectionState); };

  if (!localStream) throw new Error("Local media not started.");
  localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
}

/* ================== BANDWIDTH MONITORING ================== */
async function detectBandwidth() {
  if (!pc || pc.connectionState !== 'connected') return null;
  
  try {
    const stats = await pc.getStats();
    let outgoingBandwidth = null;
    let incomingBandwidth = null;
    let videoBitrate = null;
    let audioBitrate = null;
    
    stats.forEach(report => {
      // Available outgoing bandwidth (what we can send)
      if (report.type === 'candidate-pair' && report.state === 'succeeded') {
        if (report.availableOutgoingBitrate) {
          outgoingBandwidth = report.availableOutgoingBitrate;
        }
      }
      
      // Incoming media bitrate (what we're receiving)
      if (report.type === 'inbound-rtp' && report.kind === 'video') {
        if (report.bitrate) {
          incomingBandwidth = (incomingBandwidth || 0) + report.bitrate;
          videoBitrate = report.bitrate;
        }
      }
      
      if (report.type === 'inbound-rtp' && report.kind === 'audio') {
        if (report.bitrate) {
          incomingBandwidth = (incomingBandwidth || 0) + report.bitrate;
          audioBitrate = report.bitrate;
        }
      }
      
      // Outgoing media bitrate (what we're sending)
      if (report.type === 'outbound-rtp' && report.kind === 'video') {
        // You could track this too
      }
    });
    
    return {
      outgoing: outgoingBandwidth,
      incoming: incomingBandwidth,
      video: videoBitrate,
      audio: audioBitrate
    };
  } catch (e) {
    logDiag("Bandwidth detection error: " + e.message);
    return null;
  }
}

function updateBandwidthDisplay(bandwidthData) {
  if (bandwidthInfo) {
    if (!bandwidthData) {
      bandwidthInfo.textContent = "Bandwidth: -- kbps";
      bandwidthInfo.style.color = "#666";
      return;
    }
    
    const outgoing = bandwidthData.outgoing ? Math.round(bandwidthData.outgoing / 1000) : null;
    const incoming = bandwidthData.incoming ? Math.round(bandwidthData.incoming / 1000) : null;
    
    let status = "";
    let color = "#1976d2";
    
    // Use the lower of the two for overall quality assessment
    const minBandwidth = outgoing && incoming ? Math.min(outgoing, incoming) : outgoing || incoming;
    
    if (minBandwidth < 100) {
      color = "#f44336";
      status = " (Poor)";
    } else if (minBandwidth < 300) {
      color = "#ff9800";
      status = " (Fair)";
    } else if (minBandwidth < 1000) {
      color = "#4caf50";
      status = " (Good)";
    } else {
      color = "#1976d2";
      status = " (Excellent)";
    }
    
    let text = "";
    if (outgoing) text += `Send: ${outgoing} kbps`;
    if (incoming) text += ` | Recv: ${incoming} kbps`;
    if (bandwidthData.video) {
      text += ` | Video: ${Math.round(bandwidthData.video / 1000)} kbps`;
    }
    
    bandwidthInfo.textContent = text + status;
    bandwidthInfo.style.color = color;
  }
}

function startBandwidthMonitoring() {
  if (bandwidthCheckInterval) {
    clearInterval(bandwidthCheckInterval);
    bandwidthCheckInterval = null;
  }
  
  bandwidthCheckInterval = setInterval(async () => {
    if (isInCall && pc && pc.connectionState === 'connected') {
      const bandwidth = await detectBandwidth();
      updateBandwidthDisplay(bandwidth);      
     } else {
      updateBandwidthDisplay(null);
      stopBandwidthMonitoring();
    }
  }, 5000); // Check every 5 seconds
}

function stopBandwidthMonitoring() {
  if (bandwidthCheckInterval) {
    clearInterval(bandwidthCheckInterval);
    bandwidthCheckInterval = null;
  }
  updateBandwidthDisplay(null);
}

async function autoAdjustQuality(bandwidth) {
  if (!isInCall || !bandwidth) return;
  
  let newQuality = selectedVideoQuality;
  
  if (bandwidth < 100000) { // < 100 kbps
    newQuality = 'ultra-low';
  } else if (bandwidth < 300000) { // < 300 kbps
    newQuality = 'low';
  } else if (bandwidth < 1000000) { // < 1 Mbps
    newQuality = 'medium';
  } else { // >= 1 Mbps
    newQuality = 'high';
  }
  
  if (newQuality !== selectedVideoQuality) {
    logDiag(`Auto-adjusting quality: ${bandwidth} bps -> ${newQuality}`);
    selectedVideoQuality = newQuality;
    updateVideoQualityUi();
    
    // Don't auto-switch to audio-only, but allow switching from audio-only
    if (newQuality !== 'no-video') {
      try {
        await applyVideoQualityToCurrentStream(newQuality);
        logDiag("Auto-adjusted video quality to: " + newQuality);
      } catch (e) {
        logDiag("Auto-adjust failed: " + e.message);
      }
    }
  }
}

/* ================== FIRESTORE HELPERS ================== */
async function clearSub(col){
  const s = await getDocs(col);
  if(s.empty) return;
  const b = writeBatch(db);
  s.forEach(d=>b.delete(d.ref));
  await b.commit();
  logDiag(`Cleared subcollection ${col.path} docs=${s.size}`);
}

/* ================== UI HELPERS ================== */
function refreshCopyInviteState(){
  const hasRoomId = !!roomIdInput.value.trim();
  copyLinkBtn.disabled = !(isAuthed && hasRoomId);
}

/* ================== MEDIA + AUTOJOIN ================== */
let startingPromise = null;
let autoJoinDone = false;
let autoJoinScheduled = false;
let autoJoinTimer = null;

/* ===== Emergency video reset function ===== */
async function resetVideoTrack() {
  logDiag("Force resetting video track...");
  
  // Stop all video tracks
  if (localStream) {
    const videoTracks = localStream.getVideoTracks();
    videoTracks.forEach(track => {
      track.stop();
      localStream.removeTrack(track);
    });
  }
  
  // Clear video display
  localVideo.classList.remove('video-visible');
  localVideo.classList.add('video-hidden');
  localVideo.srcObject = null;
  
  // If we're supposed to have video, recreate it
  if (selectedVideoQuality !== 'no-video') {
    try {
      await applyVideoQualityToCurrentStream(selectedVideoQuality);
    } catch (e) {
      logDiag("Failed to recreate video: " + e.message);
    }
  }
}

 
async function startMedia(opts={skipAutoJoin:false}){
  if(!requireAuthOrPrompt()) return;

  if(localStream){
    if(!opts.skipAutoJoin) scheduleAutoJoin();
    return;
  }
  if(startingPromise) return startingPromise;

  startingPromise = (async()=>{
    hideErrorBox();

    setStatus(mediaStatus,"Requesting camera/micâ€¦");
    logDiag("Requesting getUserMediaâ€¦");

   // In startMedia() function, replace the constraints section:
const profile = VIDEO_PROFILES[selectedVideoQuality] || VIDEO_PROFILES['medium'];

// Unified constraints - 'no-video' has profile.constraints = false
const constraints = {
  audio: true,
  video: selectedVideoQuality === 'no-video' ? false : profile.constraints
};

localStream = await navigator.mediaDevices.getUserMedia(constraints);
localVideo.srcObject = localStream;

// Show/hide video based on selection
if (selectedVideoQuality === 'no-video') {
  localVideo.classList.remove('video-visible');
  localVideo.classList.add('video-hidden');
} else {
  localVideo.classList.remove('video-hidden');
  localVideo.classList.add('video-visible');
}

    // Show video element if it was hidden
    localVideo.style.display = 'block';

// Always apply the selected quality on start
try {
  await applyVideoQualityToCurrentStream(selectedVideoQuality);
} catch(e) {
  logDiag("Initial quality setup failed: " + (e?.message || e));
  // If failed, fall back to audio-only
  if (selectedVideoQuality !== 'no-video') {
    selectedVideoQuality = 'no-video';
    updateVideoQualityUi();
    videoQualityStatus.textContent = "Audio only (camera failed)";
  }
}

    setStatus(mediaStatus, selectedVideoQuality === 'no-video' ? "Mic started (audio only)." : "Camera/mic started.");
    logDiag(`${selectedVideoQuality !== 'no-video' ? "Camera/mic" : "Mic"} started (stream attached).`);

    localVideo.onloadedmetadata = async () => {
      try { await localVideo.play(); } catch {}
      setStatus(mediaStatus, selectedVideoQuality === 'no-video' ? "Mic started (audio only)." : "Camera/mic started.");
      logDiag("Local video playing.");
    };

    await loadIceServers();

    startBtn.disabled = true;
    createBtn.disabled = false;
    joinBtn.disabled   = false;

  })();

  try{ await startingPromise; }
  finally{ startingPromise = null; }

  if(!opts.skipAutoJoin) scheduleAutoJoin();
}

function cancelPendingAutoJoin(){
  autoJoinScheduled = false;
  if (autoJoinTimer) { clearTimeout(autoJoinTimer); autoJoinTimer = null; }
}

function scheduleAutoJoin(){
  if (!openedFromInvite) return;
  if (suppressAutoJoin) return;
  if (autoJoinScheduled) return;

  cancelPendingAutoJoin();
  autoJoinScheduled = true;

  autoJoinTimer = setTimeout(async ()=>{
    autoJoinScheduled = false;
    autoJoinTimer = null;
    try{ await autoJoinIfNeeded(); }
    catch(e){
      setStatus(callStatus, `Auto-join failed: ${e?.message || e}`);
      showError(e);
    }
  }, 0);
}

async function autoJoinIfNeeded(){
  if(autoJoinDone) return;
  if(!roomIdInput.value.trim()) return;

  autoJoinDone = true;
  setStatus(callStatus,"Auto-joining roomâ€¦");
  logDiag("Auto-joining triggered.");

  try{
    await joinRoom();
  }catch(e){
    autoJoinDone = false;
    throw e;
  }
}

/* ================== LISTENERS ================== */
let unsubRoomA=null, unsubCalleeA=null;
let unsubRoomB=null, unsubCallerB=null;

function stopListeners(){
  if(unsubRoomA){ unsubRoomA(); unsubRoomA=null; }
  if(unsubCalleeA){ unsubCalleeA(); unsubCalleeA=null; }
  if(unsubRoomB){ unsubRoomB(); unsubRoomB=null; }
  if(unsubCallerB){ unsubCallerB(); unsubCallerB=null; }
}

/* ================== STOP ================== */
function stopAll(){
  updateMediaConnectionStatus("Not connected");
  stopListeners();
  closePeer();
  stopCallListeners();
  stopIncomingUI();
  stopRingback();
  stopBandwidthMonitoring();
 

  if(localStream){
    localStream.getTracks().forEach(t=>t.stop());
    localStream=null;
  }
  localVideo.srcObject=null;
  localVideo.style.display = 'block'; // Reset display

  startBtn.disabled = !isAuthed;
  createBtn.disabled = true;
  joinBtn.disabled = true;

  setStatus(mediaStatus,"Not started.");
  setStatus(callStatus,"No room yet.");

  autoJoinDone = false;
  suppressAutoJoin = false;
  cancelPendingAutoJoin();

  refreshCopyInviteState();

  hangupBtn.disabled = true;
  hangupBtn.className = "hangup-btn-inactive";
  setStatus(dirCallStatus, "Idle.");

  pinnedRoomId = null;
  
  // NEW: Reset current callee when stopping all
  currentCalleeUid = null;
  isInCall = false;
  
  // NEW: Update user list to show green Call buttons again
  if (isAuthed) {
    renderUsersList(userSearchInput.value);
  }
}

/* ================== REJOIN SUPPORT ================== */
let lastSeenJoinRequestA = 0;
let lastAnsweredSessionB = null;
let bRetryTimer = null;

function clearBRetry(){
  if(bRetryTimer){ clearTimeout(bRetryTimer); bRetryTimer=null; }
}

async function requestFreshOffer(roomRef){
  lastAnsweredSessionB = null;
  await setDoc(roomRef, { joinRequest: Date.now() }, { merge:true });
  logDiag("Requested fresh offer (joinRequest).");
}

/* ================== ROOM A ================== */
let createAttemptA = 0;

async function createRoom(options={updateHash:true, reuseRoomIdInput:true, fixedRoomId:null}){
  if(!requireAuthOrPrompt()) return null;

  suppressAutoJoin = true;
  autoJoinDone = true;
  cancelPendingAutoJoin();

  stopListeners();
  clearBRetry();

  await startMedia({ skipAutoJoin:true });

  isInCall = true; // Set call state

  const myAttempt = ++createAttemptA;

  const existing =
    (options.fixedRoomId ? String(options.fixedRoomId).trim() : "") ||
    (pinnedRoomId ? String(pinnedRoomId).trim() : "") ||
    (options.reuseRoomIdInput ? roomIdInput.value.trim() : "");

  const roomRef = existing ? doc(db, "rooms", existing) : doc(collection(db, "rooms"));

  roomIdInput.value = roomRef.id;
  if (options.updateHash) location.hash = roomRef.id;

  refreshCopyInviteState();
  logDiag("CreateRoom: roomId=" + roomRef.id);

  const caller = collection(roomRef,"callerCandidates");
  const callee = collection(roomRef,"calleeCandidates");
  const snap = await getDoc(roomRef);
  const prev = snap.exists() ? (snap.data().session || 0) : 0;
  const session = Number(prev) + 1;

  if(myAttempt !== createAttemptA) return null;

  await clearSub(caller);
  await clearSub(callee);

  if(myAttempt !== createAttemptA) return null;

  await ensurePeer();

  pc.onicecandidate = (e)=>{
    if(e.candidate){
      addDoc(caller, { session, ...e.candidate.toJSON() }).catch(()=>{});
    }
  };

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  await setDoc(roomRef, {
    session,
    offer: { type: offer.type, sdp: offer.sdp },
    answer: null,
    updatedAt: Date.now()
  }, { merge:true });

  setStatus(callStatus, `Room active (session ${session}).`);
  logDiag(`Room written. session=${session}`);

  unsubRoomA = onSnapshot(roomRef, async (s)=>{
    if(myAttempt !== createAttemptA) return;
    const d = s.data();
    if(!d) return;

    if(d.joinRequest && d.joinRequest > lastSeenJoinRequestA){
      lastSeenJoinRequestA = d.joinRequest;
      setStatus(callStatus, "Join request received â€” restarting sessionâ€¦");
      logDiag("JoinRequest seen => restarting offer/session.");
      setTimeout(()=>createRoom({ ...options, fixedRoomId: roomRef.id, reuseRoomIdInput: true }).catch(()=>{}), 150);
      return;
    }

    if(d.answer && d.session === session && pc && pc.signalingState === "have-local-offer" && !pc.currentRemoteDescription){
      try{
        await pc.setRemoteDescription(d.answer);
        setStatus(callStatus, `Connected (session ${session}).`);
        logDiag("Applied remote answer.");
      }catch(e){
        logDiag("setRemoteDescription(answer) failed: " + (e?.message || e));
        setStatus(callStatus, "Answer failed â€” restarting sessionâ€¦");
        setTimeout(()=>createRoom({ ...options, fixedRoomId: roomRef.id, reuseRoomIdInput: true }).catch(()=>{}), 200);
      }
    }
  });

  unsubCalleeA = onSnapshot(callee, (ss)=>{
    ss.docChanges().forEach(ch=>{
      if(ch.type !== "added" || !pc) return;
      const c = ch.doc.data();
      if(c.session !== session) return;
      try{ pc.addIceCandidate(c); }catch{}
    });
  });

  return { roomId: roomRef.id, roomRef };
}

/* ================== ROOM B ================== */
let joinAttemptB = 0;

async function joinRoom(){
  if(!requireAuthOrPrompt()) return;

  suppressAutoJoin = false;
  await startMedia({ skipAutoJoin:true });
  
  isInCall = true; // Set call state

  const myAttempt = ++joinAttemptB;
  stopListeners();
  clearBRetry();

  const roomId = roomIdInput.value.trim();
  if(!roomId) throw new Error("Room ID is empty.");
  location.hash = roomId;

  logDiag("JoinRoom: roomId=" + roomId);

  const roomRef = doc(db,"rooms", roomId);
  const snap = await getDoc(roomRef);
  if(!snap.exists()) throw new Error("Room not found");

  await requestFreshOffer(roomRef);
  if(myAttempt !== joinAttemptB) return;

  setStatus(callStatus, "Connectingâ€¦ (requested fresh offer)");

  unsubRoomB = onSnapshot(roomRef, async (s)=>{
    if(myAttempt !== joinAttemptB) return;
    const d = s.data();
    if(!d?.offer || !d.session) return;

    if(lastAnsweredSessionB === d.session) return;

    const session = d.session;
    lastAnsweredSessionB = session;
    logDiag("New offer/session detected: " + session);

    try{
      await ensurePeer();

      const caller = collection(roomRef,"callerCandidates");
      const callee = collection(roomRef,"calleeCandidates");

      await clearSub(callee);
      if(myAttempt !== joinAttemptB) return;

      pc.onicecandidate = (e)=>{
        if(e.candidate){
          addDoc(callee, { session, ...e.candidate.toJSON() }).catch(()=>{});
        }
      };

      await pc.setRemoteDescription(d.offer);
      const ans = await pc.createAnswer();
      await pc.setLocalDescription(ans);

      await updateDoc(roomRef, { answer: ans, session, answeredAt: Date.now() });
      setStatus(callStatus, `Joined room. Connectingâ€¦ (session ${session})`);
      logDiag("Answer written to room doc.");

      unsubCallerB = onSnapshot(caller, (ss)=>{
        if(myAttempt !== joinAttemptB) return;
        ss.docChanges().forEach(ch=>{
          if(ch.type !== "added" || !pc) return;
          const c = ch.doc.data();
          if(c.session !== session) return;
          try{ pc.addIceCandidate(c); }catch{}
        });
      });

      clearBRetry();
      bRetryTimer = setTimeout(async ()=>{
        if(myAttempt !== joinAttemptB) return;
        if(!pc) return;
        if(pc.connectionState === "connected") return;

        setStatus(callStatus, "Still connectingâ€¦ retrying (requesting new offer)â€¦");
        logDiag("Watchdog: requesting fresh offer again.");
        try{
          lastAnsweredSessionB = null;
          await requestFreshOffer(roomRef);
        }catch(e){ showError(e); }
      }, 10000);

      pc.onconnectionstatechange = async ()=>{
        if(myAttempt !== joinAttemptB || !pc) return;
        setStatus(callStatus, `B: ${pc.connectionState} (session ${session})`);
        if(pc.connectionState === "connected"){ clearBRetry(); }
        if(pc.connectionState === "failed" || pc.connectionState === "disconnected"){
          setStatus(callStatus, "Connection lost â€” requesting new offerâ€¦");
          logDiag("Connection lost => requesting fresh offer.");
          try{
            lastAnsweredSessionB = null;
            await requestFreshOffer(roomRef);
          }catch(e){ showError(e); }
        }
      };

    }catch(e){
      lastAnsweredSessionB = null;
      logDiag("Join flow error: " + (e?.message || e));
      setStatus(callStatus, "Join failed â€” requesting new offerâ€¦");
      try{ await requestFreshOffer(roomRef); }catch(err){ showError(err); }
    }
  });
}

/* ================== COPY INVITE ================== */
async function copyTextRobust(text){
  if(navigator.clipboard && window.isSecureContext){
    try{ await navigator.clipboard.writeText(text); return true; }catch{}
  }
  window.prompt("Copy this invite link:", text);
  return false;
}

copyLinkBtn.onclick = async ()=>{
  const roomId = roomIdInput.value.trim();
  if(!roomId) return;
  const invite = `${location.origin}${location.pathname}#${roomId}`;
  const ok = await copyTextRobust(invite);
  setStatus(callStatus, ok ? "Invite copied." : "Clipboard blocked â€” link shown for manual copy.");
  logDiag("Copy invite clicked.");
};

/* ================== RINGTONE ================== */
let audioCtx = null;
let ringOsc = null;
let ringGain = null;
let ringTimer = null;

function ensureAudio(){
  if(!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  return audioCtx;
}
async function unlockAudio(){
  try{
    const ctx = ensureAudio();
    if(ctx.state !== "running") await ctx.resume();
  }catch{}
}
window.addEventListener("click", ()=>{ unlockAudio(); }, { once:false, passive:true });

function startRingtone(){
  stopRingtone();
  try{
    const ctx = ensureAudio();
    if(ctx.state !== "running") ctx.resume().catch(()=>{});
    ringGain = ctx.createGain();
    ringGain.gain.value = 0.10;
    ringGain.connect(ctx.destination);

    ringOsc = ctx.createOscillator();
    ringOsc.type = "sine";
    ringOsc.frequency.value = 880;
    ringOsc.connect(ringGain);
    ringOsc.start();

    let on = true;
    ringTimer = setInterval(()=>{
      if(!ringGain) return;
      ringGain.gain.value = on ? 0.10 : 0.0001;
      on = !on;
    }, 450);

    logDiag("Ringtone started.");
  }catch(e){
    logDiag("Ringtone failed: " + (e?.message || e));
  }
}
function stopRingtone(){
  if(ringTimer){ clearInterval(ringTimer); ringTimer=null; }
  try{ if(ringOsc){ ringOsc.stop(); } }catch{}
  try{ if(ringOsc){ ringOsc.disconnect(); } }catch{}
  try{ if(ringGain){ ringGain.disconnect(); } }catch{}
  ringOsc = null;
  ringGain = null;
}
/* ================== CALLER RINGBACK (quiet beeps) ================== */
let ringbackTimer = null;

function stopRingback(){
  if(ringbackTimer){
    clearInterval(ringbackTimer);
    ringbackTimer = null;
  }
}

function playRingbackBeepOnce(){
  try{
    const ctx = ensureAudio();
    if(ctx.state !== "running") ctx.resume().catch(()=>{});

    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    gain.gain.value = 0.04;     // quiet volume
    osc.type = "sine";
    osc.frequency.value = 440;  // phone-ish

    osc.connect(gain);
    gain.connect(ctx.destination);

    const now = ctx.currentTime;
    osc.start(now);
    osc.stop(now + 0.18);

    osc.onended = ()=>{
      try{ osc.disconnect(); }catch{}
      try{ gain.disconnect(); }catch{}
    };
  }catch{}
}

function startRingback(){
  stopRingback();

  // Ensure audio is unlocked (browser policy)
  try{ unlockAudio(); }catch{}

  // Pattern: beep, 250ms later beep, then ~2s pause, repeat
  const cycleMs = 2500;

  playRingbackBeepOnce();
  setTimeout(()=> playRingbackBeepOnce(), 250);

  ringbackTimer = setInterval(()=>{
    playRingbackBeepOnce();
    setTimeout(()=> playRingbackBeepOnce(), 250);
  }, cycleMs);
}

/* ================== CALLS (UID-based) ================== */
let currentIncomingCall = null; // { id, data }
let activeCallId = null;        // NEW: callId for BOTH sides (caller OR callee)
let lastDismissedIncomingCallId = null;

let unsubIncoming = null;
let unsubCallDoc = null;

function stopCallListeners(){
  if(unsubIncoming){ unsubIncoming(); unsubIncoming=null; }
  if(unsubCallDoc){ unsubCallDoc(); unsubCallDoc=null; }
  currentIncomingCall = null;
  activeCallId = null;
}

function showIncomingUI(callId, data){
  currentIncomingCall = { id: callId, data };
  incomingText.textContent = `Call from ${data.fromName || "unknown"}â€¦`;

  // Let caller know callee browser received/displayed invite
  if (!data?.deliveredAt) {
    updateDoc(doc(db,"calls", callId), {
      deliveredAt: serverTimestamp(),
      deliveredVia: "firestore",
      deliveredAtMs: Date.now()  // Add milliseconds timestamp for precise timing
    }).catch(()=>{});
  }

  // MARK THAT WEB PAGE HANDLED NOTIFICATION
  webPageShowedNotification = true;
  console.log('Web page showing incoming call UI, marking as delivered');

  incomingOverlay.style.display = "flex";
  startRingtone();
}

function stopIncomingUI(){
  incomingOverlay.style.display = "none";
  stopRingtone();
  lastDismissedIncomingCallId = currentIncomingCall?.id || lastDismissedIncomingCallId;
  currentIncomingCall = null;
}

async function listenIncomingCalls(){
  if(!myUid) return;

  if(unsubIncoming){ unsubIncoming(); unsubIncoming=null; }

  const qy = query(
    collection(db, "calls"),
    where("toUid", "==", myUid),
    where("status", "==", "ringing"),
    orderBy("createdAt", "desc"),
    limit(1)
  );

  unsubIncoming = onSnapshot(qy, (snap)=>{
    if(snap.empty) return;
    const d = snap.docs[0];
    const data = d.data();

    if (d.id === lastDismissedIncomingCallId) return;
    if(currentIncomingCall?.id === d.id) return;

    logDiag("Incoming call (Firestore): " + d.id);
    showIncomingUI(d.id, data);
  }, (err)=>{
    logDiag("Incoming call listener error: " + (err?.message || err));
  });
}

// Catch-up: if Chrome was closed and push was missed, show the newest ringing call after login
async function catchUpMissedRingingCall() {
  try {
    if (!myUid) return;

    // 1) Query newest ringing call addressed to me
    const qy = query(
      collection(db, "calls"),
      where("toUid", "==", myUid),
      where("status", "==", "ringing"),
      orderBy("createdAt", "desc"),
      limit(1)
    );

    const snap = await getDocs(qy);
    if (snap.empty) return;

    const d = snap.docs[0];
    const callId = d.id;
    const call = d.data() || {};
    if (pendingIncomingCallWhileLoggedOut?.id === callId) return;
    if (currentIncomingCall?.id === callId) return;

    // 2) Derive created time (ms) safely
    const createdMs =
      (call.createdAt && typeof call.createdAt.toMillis === "function")
        ? call.createdAt.toMillis()
        : Date.now();

    // 3) Show in-page incoming UI (works even if notifications are blocked)
    roomIdInput.value = call.roomId || "";
    currentIncomingCall = { id: callId, data: call };
    incomingText.textContent = `Call from ${call.fromName || "unknown"}â€¦`;
    incomingOverlay.style.display = "flex";
    startRingtone();

    // Update Person B title with caller's name for the UI
    if (call.fromName) {
      updatePersonBTitle(call.fromName);
    }
   
    // 4) Optional: also show a system notification (if permission granted)
    if ("Notification" in window && Notification.permission === "granted") {
      const reg = await navigator.serviceWorker.getRegistration("/easosunov/");
      if (reg) {
        const fromName = call.fromName || "Unknown";
        const note = String(call.note || "").trim();
        const tsLocal = new Date(createdMs).toLocaleString();

        const body =
          `Call from ${fromName}` +
          (note ? ` â€” ${note}` : "") +
          ` â€” ${tsLocal}`;

        await reg.showNotification("Incoming call", {
          body,
          tag: `webrtc-call-${myUid}`,
          renotify: true,
          requireInteraction: true,
          data: { callId, roomId: call.roomId || "", fromName, note }
        });
      }
    }

    logDiag("Catch-up: showed ringing call " + callId);
  } catch (e) {
    logDiag("catchUpMissedRingingCall failed: " + (e?.message || e));
  }
}

// Catch-up: if Chrome was closed and the call became MISSED, show newest missed call after login
async function catchUpMissedCallNotification() {
  try {
    if (!myUid) return;

    // 0) Don't repeat the same missed call notification forever
    const LS_LAST_MISSED = "webrtc_last_missed_call_id";
    const lastId = String(localStorage.getItem(LS_LAST_MISSED) || "");

    // Helper to show system notification
    async function showMissed(callId, call, whenMs) {
      const fromName = call.fromName || "Unknown";
      const note = String(call.note || "").trim();
      const tsLocal = new Date(whenMs).toLocaleString();

      // Always update in-page status so you can debug even if notifications are blocked
      setStatus(dirCallStatus, `Missed call from ${fromName}.`);
      logDiag(`Catch-up: MISSED/ENDED call found ${callId} from=${fromName}`);

      if ("Notification" in window && Notification.permission === "granted") {
        const reg = await navigator.serviceWorker.getRegistration("/easosunov/");
        if (reg) {
          const body =
            `Missed call from ${fromName}` +
            (note ? ` â€” ${note}` : "") +
            ` â€” ${tsLocal}`;

          await reg.showNotification("Missed call", {
            body,
            tag: `webrtc-missed-${myUid}`,
            renotify: true,
            requireInteraction: true,
            data: { callId, roomId: call.roomId || "", fromName, note }
          });
        }
      }

      localStorage.setItem(LS_LAST_MISSED, callId);
    }

    // 1) First, try newest explicit MISSED call
    {
      const q1 = query(
        collection(db, "calls"),
        where("toUid", "==", myUid),
        where("status", "==", "missed"),
        orderBy("missedAt", "desc"),
        limit(1)
      );

      const s1 = await getDocs(q1);
      if (!s1.empty) {
        const d = s1.docs[0];
        const callId = d.id;
        const call = d.data() || {};

        if (callId && callId !== lastId &&
            pendingIncomingCallWhileLoggedOut?.id !== callId &&
            currentIncomingCall?.id !== callId) {

          const missedMs =
            (call.missedAt && typeof call.missedAt.toMillis === "function")
              ? call.missedAt.toMillis()
              : Date.now();

          await showMissed(callId, call, missedMs);
          return;
        }
      }
    }

    // 2) If not found, treat "ended" as missed IF it was never accepted/declined
    {
      const q2 = query(
        collection(db, "calls"),
        where("toUid", "==", myUid),
        where("status", "==", "ended"),
        orderBy("endedAt", "desc"),
        limit(5) // check a few, because newest ended might be a real answered call
      );

      const s2 = await getDocs(q2);
      if (s2.empty) return;

      for (const docSnap of s2.docs) {
        const callId = docSnap.id;
        const call = docSnap.data() || {};

        // Skip if it was actually answered or declined
        const hadAccept = !!call.acceptedAt;
        const hadDecline = !!call.declinedAt;
        if (hadAccept || hadDecline) continue;

        if (callId && callId !== lastId &&
            pendingIncomingCallWhileLoggedOut?.id !== callId &&
            currentIncomingCall?.id !== callId) {

          const endedMs =
            (call.endedAt && typeof call.endedAt.toMillis === "function")
              ? call.endedAt.toMillis()
              : Date.now();

          await showMissed(callId, call, endedMs);
          return;
        }
      }
    }

  } catch (e) {
    logDiag("catchUpMissedCallNotification failed: " + (e?.message || e));
  }
}

function cleanupCallUI(){
  hangupBtn.disabled = true;
  hangupBtn.className = "hangup-btn-inactive";
  activeCallId = null;
  if(unsubCallDoc){ unsubCallDoc(); unsubCallDoc=null; }
  pinnedRoomId = null;
}

/* ===== FIXED: Enhanced listenActiveCall function ===== */
function listenActiveCall(callId) {
  // Don't start if we're already connected
  if (pc && pc.connectionState === "connected") {
    setStatus(dirCallStatus, "Answered. Connected.");
    return;
  }
  
  // Early exit if already connected
  if (dirCallStatus.textContent.includes("Connected") || 
      dirCallStatus.textContent === "Answered. Connected.") {
    return;
  }
  
  if (unsubCallDoc) {
    unsubCallDoc();
    unsubCallDoc = null;
  }

  unsubCallDoc = onSnapshot(doc(db, "calls", callId), (s) => {
    if (!s.exists()) return;
    const d = s.data();
    if (!d) return;

    // STOP PROCESSING if WebRTC is connected
    if (pc && pc.connectionState === "connected") {
      setStatus(dirCallStatus, "Answered. Connected.");
      return;
    }

    // If the other side ends the call, clean everything up locally
    if (d.status === "ended") {
      stopRingback();
      setStatus(dirCallStatus, "Ended.");
      logDiag("Call ended (remote).");
      cleanupCallUI();
      stopAll(); // full local cleanup
      // Reset Person B title
      updatePersonBTitle('Other');
      // Reset current callee
      currentCalleeUid = null;
      isInCall = false;
      // Update user list to show green Call buttons
      if (isAuthed) {
        renderUsersList(userSearchInput.value);
      }
      return;
    }

    // Optional: keep your existing status feedback
    if (d.status === "accepted") {
      stopRingback();
      setStatus(dirCallStatus, "Answered. Connectingâ€¦");
      return;
    }
    
    if (d.status === "declined") {
      stopRingback();
      setStatus(dirCallStatus, "Declined.");
      logDiag("Call declined.");
      cleanupCallUI();
      // Reset current callee
      currentCalleeUid = null;
      isInCall = false;
      // Update user list to show green Call buttons
      if (isAuthed) {
        renderUsersList(userSearchInput.value);
      }
      return;
    }
    
    if (d.status === "missed") {
      stopRingback();
      setStatus(dirCallStatus, "Missed.");
      logDiag("Call missed.");
      cleanupCallUI();
      // Reset current callee
      currentCalleeUid = null;
      isInCall = false;
      // Update user list to show green Call buttons
      if (isAuthed) {
        renderUsersList(userSearchInput.value);
      }
      return;
    }

    if (d.deliveredAt) {
      setStatus(dirCallStatus, "Delivered (callee page open).");
      return;
    }

    // Only check push stage if call is still ringing
    if (d.push?.stage === "sent" && d.status === "ringing") { 
      setStatus(dirCallStatus, "Push sent (waiting for answer)..."); 
      return; 
    }
    
    if (d.push?.stage === "no_tokens") { 
      setStatus(dirCallStatus, "No push tokens for callee (tab must be open)."); 
      return; 
    }
    
    if (d.push?.stage === "error") { 
      setStatus(dirCallStatus, "Push error (see call doc push.error)."); 
      return; 
    }

    // Default status
    setStatus(dirCallStatus, "Ringingâ€¦");
  });
}

async function hangup(){
  updateMediaConnectionStatus("Not connected");
  stopRingback();
  // Reset Person B title
  updatePersonBTitle('Other');
  
  isInCall = false;
 
  // NEW: works for BOTH caller and callee
  if (activeCallId) {
    try {
      const callRef = doc(db, "calls", activeCallId);
      const snap = await getDoc(callRef);

      if (snap.exists()) {
        const call = snap.data() || {};

        // If caller hangs up BEFORE callee answered/declined â†’ MISSED
        if (call.status === "ringing") {
          await updateDoc(callRef, {
            status: "missed",
            missedAt: serverTimestamp(),
            endedAt: serverTimestamp(),
            updatedAt: serverTimestamp(),
          });
        } else {
          // Normal hangup after answer
          await updateDoc(callRef, {
            status: "ended",
            endedAt: serverTimestamp(),
            updatedAt: serverTimestamp(),
          });
        }
      }
    } catch(e) {
      showError(e);
    }
  }

  // FULL local cleanup
  stopAll();
  cleanupCallUI();
  setStatus(dirCallStatus, "Ended.");
  // Reset current callee
  currentCalleeUid = null;
  // Update user list to show green Call buttons again
  if (isAuthed) {
    renderUsersList(userSearchInput.value);
  }
  try { await loadRecentCalls(); } catch {} // Refresh calls list
}

/* Answer / Decline buttons for incoming */
answerBtn.onclick = async ()=>{
  try{
    const call = currentIncomingCall;
    stopIncomingUI();

    if(!call){
      setStatus(dirCallStatus, "No call context. Please wait for the caller again.");
      return;
    }

    const { id, data } = call;

    await updateDoc(doc(db,"calls", id), {
      status: "accepted",
      acceptedAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });

    // Clear notification flag
    webPageShowedNotification = false;
    localStorage.removeItem('pendingNotificationCall');

    // Set call state
    isInCall = true;

    // NEW: Set current callee when accepting incoming call
    currentCalleeUid = data.fromUid || null;

    // NEW: Callee now has an active call id and can hang up
    activeCallId = id;
    hangupBtn.disabled = false;
    hangupBtn.className = "hangup-btn-active";
    listenActiveCall(id);

    roomIdInput.value = data.roomId;

    setStatus(dirCallStatus, `Answered ${data.fromName || ""}. Joining roomâ€¦`);
    
    // Update Person B title with caller's name
    if (data.fromName) {
      updatePersonBTitle(data.fromName);
    }

    // Update user list to show white Call buttons (call is active)
    renderUsersList(userSearchInput.value);

    await joinRoom();

    try { await listenIncomingCalls(); } catch {}
    try { await loadRecentCalls(); } catch {} // Refresh calls list
  }catch(e){
    showError(e);
  }
};

declineBtn.onclick = async ()=>{
  try {
    // First, do exactly what hangup() does
    stopRingback();
    // Reset Person B title
    updatePersonBTitle('Other');
    
    // Set call state
    isInCall = false;
    
    // If there's an active call ID, update it to "declined" in Firestore
    if (activeCallId) {
      try {
        const callRef = doc(db, "calls", activeCallId);
        const snap = await getDoc(callRef);

        if (snap.exists()) {
          const call = snap.data() || {};
          
          // If caller hangs up BEFORE callee answered/declined â†’ MISSED
          if (call.status === "ringing") {
            await updateDoc(callRef, {
              status: "declined",
              declinedAt: serverTimestamp(),
              endedAt: serverTimestamp(),
              updatedAt: serverTimestamp(),
            });
          } else {
            // Normal hangup after answer
            await updateDoc(callRef, {
              status: "declined",
              declinedAt: serverTimestamp(),
              endedAt: serverTimestamp(),
              updatedAt: serverTimestamp(),
            });
          }
        }
      } catch(e) {
        showError(e);
      }
    }

    // Also update any incoming call that might not be activeCallId yet
    const call = currentIncomingCall;
    if (call && call.id) {
      try {
        await updateDoc(doc(db, "calls", call.id), {
          status: "declined",
          declinedAt: serverTimestamp(),
          updatedAt: serverTimestamp()
        });
      } catch(e) {
        // Ignore errors if already updated above
      }
    }

    // FULL local cleanup (same as hangup())
    stopAll();
    
    // Cleanup call UI (same as hangup())
    hangupBtn.disabled = true;
    hangupBtn.className = "hangup-btn-inactive";
    activeCallId = null;
    if(unsubCallDoc){ unsubCallDoc(); unsubCallDoc=null; }
    pinnedRoomId = null;
    
    // Stop incoming UI
    stopIncomingUI();

    setStatus(dirCallStatus, "Declined and disconnected.");
    
    // Clear notification flag
    webPageShowedNotification = false;
    localStorage.removeItem('pendingNotificationCall');
    
    // Reset current callee
    currentCalleeUid = null;
    
    // Update user list to show green Call buttons again
    if (isAuthed) {
      renderUsersList(userSearchInput.value);
    }

    // Restart listeners and refresh
    try { await listenIncomingCalls(); } catch {}
    try { await loadRecentCalls(); } catch {}
  } catch(e) {
    showError(e);
  }
};

/* ================== USER DIRECTORY (C-lite) ================== */
let myDisplayName = "";
let allUsersCache = []; // [{uid, displayName}]

function defaultNameFromEmail(email){
  const e = String(email || "").trim();
  if(!e) return "";
  return e.split("@")[0].slice(0, 24);
}

async function ensureMyUserProfile(user){
  const ref = doc(db, "users", user.uid);
  const snap = await getDoc(ref);

  const existing = snap.exists() ? (snap.data() || {}) : {};
  const name = existing.displayName || defaultNameFromEmail(user.email);

  await setDoc(ref, {
    uid: user.uid,
    displayName: name,
    updatedAt: serverTimestamp()
  }, { merge: true });

  myDisplayName = name;
  myNameInput.value = name || "";
  myNameStatus.textContent = name ? `Saved: ${name}` : "Not set.";
  
  // Update Person A title with username
  updatePersonATitle();
}


// Function to update Person A title with username
function updatePersonATitle() {
  const personATitle = document.getElementById('personATitle');
  if (personATitle && myDisplayName) {
    personATitle.textContent = `Person A (${myDisplayName})`;
  } else if (personATitle) {
    personATitle.textContent = 'Person A (You)';
  }
}

// Function to update Person B title with username
function updatePersonBTitle(username = 'Other') {
  const personBTitle = document.getElementById('personBTitle');
  if (personBTitle) {
    if (username && username !== 'Other') {
      personBTitle.textContent = `Person B (${username})`;
    } else {
      personBTitle.textContent = 'Person B (Other)';
    }
  }
}

// Function to update user info display with phone/email badges
function updateUserInfo() {
  const userInfoDiv = document.getElementById('personATitle');
  if (userInfoDiv && myDisplayName) {
    let infoHtml = `Person A (${myDisplayName})`;
    if (isAndroidPhoneLogin && userPhone) {
      infoHtml += ` <span class="phone-badge">ðŸ“± ${userPhone}</span>`;
    } else if (auth.currentUser?.email) {
      infoHtml += ` <span class="email-badge">âœ‰ï¸ ${auth.currentUser.email}</span>`;
    }
    userInfoDiv.innerHTML = infoHtml;
  }
}
 
async function saveMyName(){
  if(!requireAuthOrPrompt()) return;

  const name = String(myNameInput.value || "").trim();
  if(!name) throw new Error("Name cannot be empty.");
  if(name.length > 40) throw new Error("Name is too long (max 40).");

  await setDoc(doc(db, "users", myUid), {
    displayName: name,
    updatedAt: serverTimestamp()
  }, { merge:true });

  myDisplayName = name;
  myNameStatus.textContent = `Saved: ${name}`;
  logDiag("Saved displayName=" + name);
  
  // Update Person A title with new username
  updatePersonATitle();
  updateUserInfo();
}

function chunk(arr, n){
  const out = [];
  for(let i=0;i<arr.length;i+=n) out.push(arr.slice(i, i+n));
  return out;
}

function renderUsersList(filterText=""){
  const q = String(filterText || "").trim().toLowerCase();
  const rows = allUsersCache
    .filter(u => u.uid !== myUid)
    .filter(u => !q || String(u.displayName||"").toLowerCase().includes(q))
    .sort((a,b)=> String(a.displayName||"").localeCompare(String(b.displayName||"")));

  usersList.innerHTML = "";

  if(rows.length === 0){
    usersList.innerHTML = `<div class="small" style="color:#777">No users found.</div>`;
    return;
  }

  for(const u of rows){
    const div = document.createElement("div");
    div.style.display = "flex";
    div.style.alignItems = "center";
    div.style.justifyContent = "space-between";
    div.style.gap = "10px";
    div.style.border = "1px solid #eee";
    div.style.borderRadius = "10px";
    div.style.padding = "10px";

    const left = document.createElement("div");
    left.innerHTML = `<b>${u.displayName || "(no name)"}</b>`;

    const btn = document.createElement("button");
    btn.textContent = "Call";
    btn.disabled = !isAuthed;
    
    // Apply button color classes
    if (!isAuthed || isInCall) {
      // If not authenticated OR there's an active call (isInCall = true), buttons are white
      btn.className = "call-btn-inactive-other";
    } else if (currentCalleeUid && u.uid === currentCalleeUid) {
      // If this is the person we're currently calling (or who called us)
      btn.className = "call-btn-inactive-callee";
    } else {
      // Normal state - user can make calls (green)
      btn.className = "call-btn-active";
    }
    
    btn.onclick = ()=> startCallToUid(u.uid, u.displayName).catch(showError);

    div.appendChild(left);
    div.appendChild(btn);
    usersList.appendChild(div);
  }
}

async function loadAllAllowedUsers(){
  if(!requireAuthOrPrompt()) return;

  const alSnap = await getDocs(
    query(collection(db,"allowlistUids"), where("enabled","==",true), limit(200))
  );
  const uids = alSnap.docs.map(d => d.id).filter(Boolean);

  const users = [];
  for(const group of chunk(uids, 10)){
    const usSnap = await getDocs(query(collection(db,"users"), where(documentId(), "in", group)));
    usSnap.forEach(docu => {
      const d = docu.data() || {};
      users.push({ uid: docu.id, displayName: d.displayName || "" });
    });
  }

  allUsersCache = users;
  renderUsersList(userSearchInput.value);
  logDiag("Loaded users directory: " + users.length);
}


/* ================== RECENT CALLS LIST ================== */
async function loadRecentCalls() {
  if (!requireAuthOrPrompt()) return;
  
  try {
    // Get incoming calls
    const q1 = query(
      collection(db, "calls"),
      where("toUid", "==", myUid)
    );
    
    // Get outgoing calls  
    const q2 = query(
      collection(db, "calls"),
      where("fromUid", "==", myUid)
    );
    
    const [snap1, snap2] = await Promise.all([
      getDocs(q1),
      getDocs(q2)
    ]);
    
    // Combine all calls
    const allCalls = [];
    
    // Process incoming calls
    snap1.docs.forEach(doc => {
      const data = doc.data();
      allCalls.push({ 
        id: doc.id, 
        ...data,
        direction: 'incoming',
        timestamp: data.createdAt?.toMillis?.() || data.createdAt?._seconds * 1000 || 0
      });
    });
    
    // Process outgoing calls
    snap2.docs.forEach(doc => {
      const data = doc.data();
      allCalls.push({ 
        id: doc.id, 
        ...data,
        direction: 'outgoing',
        timestamp: data.createdAt?.toMillis?.() || data.createdAt?._seconds * 1000 || 0
      });
    });
    
    logDiag(`DEBUG: Total calls before deduplication: ${allCalls.length}`);
    
    // Sort by timestamp (newest first) for processing
    allCalls.sort((a, b) => b.timestamp - a.timestamp);
    
    // Deduplicate based on similar content and time
    const deduplicated = [];
    const seenKeys = new Set();
    
    // Time window for considering duplicates (5 minutes = 300000 ms)
    const DUPLICATE_TIME_WINDOW = 5 * 60 * 1000;
    
    allCalls.forEach(call => {
      // Create a unique key based on: other user + direction + status + time window
      const otherUid = call.direction === 'incoming' ? call.fromUid : call.toUid;
      const timeBucket = Math.floor(call.timestamp / DUPLICATE_TIME_WINDOW);
      const key = `${otherUid}_${call.direction}_${call.status}_${timeBucket}`;
      
      if (!seenKeys.has(key)) {
        seenKeys.add(key);
        deduplicated.push(call);
      } else {
        logDiag(`DEBUG: Skipping duplicate: ${call.id} (key: ${key})`);
      }
    });
    
    logDiag(`DEBUG: After content-based deduplication: ${deduplicated.length} calls`);
    
    // Take only the most recent 30 calls
    const recentCalls = deduplicated
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, 30);
    
    // DEBUG: Log final list
    logDiag(`DEBUG: Final calls list has ${recentCalls.length} items`);
    recentCalls.forEach((call, index) => {
      logDiag(`DEBUG: [${index}] ${call.id} - ${call.fromName} to ${call.toName} - ${call.status} - ${new Date(call.timestamp).toLocaleString()}`);
    });
    
    renderCallsList(recentCalls);
    logDiag(`Loaded ${recentCalls.length} recent calls (content-deduplicated)`);
    
  } catch (error) {
    logDiag("Error loading recent calls: " + error.message);
    callsList.innerHTML = `<div style="color:#f44336;text-align:center;">Error: ${error.message}</div>`;
  }
}


function renderCallsList(calls) {
  if (!callsList || calls.length === 0) {
    callsList.innerHTML = `<div style="color:#777;text-align:center;">No calls yet</div>`;
    return;
  }
  
  let html = '';
  
  calls.forEach(call => {
    const isIncoming = call.toUid === myUid;
    const isOutgoing = call.fromUid === myUid;
    const status = call.status || 'unknown';
    
    // Determine CSS class based on status and direction
    let statusClass = '';
    if (status === 'ringing') statusClass = 'call-ringing';
    else if (status === 'accepted') statusClass = 'call-accepted';
    else if (status === 'declined') statusClass = 'call-declined';
    else if (status === 'missed') statusClass = 'call-missed';
    else if (status === 'ended') statusClass = 'call-ended';
    else if (isIncoming) statusClass = 'call-incoming';
    else if (isOutgoing) statusClass = 'call-outgoing';
    
    // Format timestamp
    let timeText = '';
    if (call.createdAt) {
      const timeMs = call.createdAt.toMillis ? call.createdAt.toMillis() : Date.now();
      const date = new Date(timeMs);
      timeText = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    }
    
    // Determine display text
    const otherName = isIncoming ? call.fromName || 'Unknown' : call.toName || 'Unknown';
    const directionIcon = isIncoming ? 'ðŸ“¥' : 'ðŸ“¤';
    const directionText = isIncoming ? 'From' : 'To';
    const note = call.note || '';
    
    // Format the call entry
    html += `
      <div class="call-item ${statusClass}" style="min-height: ${note ? '60px' : 'auto'};">
        <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 8px;">
          <div style="flex: 1; min-width: 0;">
            <div style="font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
              ${directionIcon} ${directionText}: ${otherName}
            </div>
            <div style="font-size: 10px; color: #666; margin-top: 2px;">
              ${timeText}
            </div>
          </div>
          <div style="font-size: 10px; background: ${getStatusColor(status)}; color: white; padding: 2px 6px; border-radius: 10px; white-space: nowrap;">
            ${status}
          </div>
        </div>
        ${note ? `
        <div style="margin-top: 6px; padding: 4px 6px; background: rgba(0,0,0,0.03); border-radius: 4px; border-left: 2px solid #ddd; font-size: 10px; color: #555; white-space: pre-wrap; word-break: break-word;">
          ${note}
        </div>
        ` : ''}
      </div>
    `;
  });
  
  callsList.innerHTML = html;
}

// Helper function to get status color
function getStatusColor(status) {
  switch(status) {
    case 'ringing': return '#FFC107';
    case 'accepted': return '#8BC34A';
    case 'declined': return '#FF9800';
    case 'missed': return '#f44336';
    case 'ended': return '#9E9E9E';
    default: return '#757575';
  }
}

 
async function startCallToUid(toUid, toName=""){
  logDiag("startCallToUid(): ENTER toUid=" + toUid);

  if(!requireAuthOrPrompt()) return;
  if(!toUid) throw new Error("Missing toUid.");
  if(toUid === myUid) throw new Error("You can't call yourself.");

  setStatus(dirCallStatus, "Creating roomâ€¦");
  const created = await createRoom({ updateHash:false, reuseRoomIdInput:false, fixedRoomId:null });
  if(!created?.roomId) throw new Error("Room creation failed.");

  pinnedRoomId = created.roomId;

  const note = String(callNoteInput?.value || "").trim().slice(0, 140);

   // Update Person B title with recipient's name
  if (toName) {
    updatePersonBTitle(toName);
  }

  const callRef = await addDoc(collection(db,"calls"), {
  fromUid: myUid,
  toUid,
  fromName: myDisplayName || defaultNameFromEmail(emailInput?.value) || "(unknown)",
  toName: toName || "",
  roomId: created.roomId,
  note,
  status: "ringing",
  createdAt: serverTimestamp(),
  updatedAt: serverTimestamp(),

  // NEW: lifecycle markers
  acceptedAt: null,
  declinedAt: null,
  endedAt: null
});

// NEW: SEND FCM PUSH NOTIFICATION TO ANDROID
try {
  await sendFCMToAndroid(toUid, created.roomId, myDisplayName, note, callRef.id);
} catch (e) {
  console.error("Error sending FCM to Android:", e);
}

  activeCallId = callRef.id;
  // NEW: Set current callee
  currentCalleeUid = toUid;
  
  // Update Hang up button to active state
  hangupBtn.disabled = false;
  hangupBtn.className = "hangup-btn-active";
  
  // NEW: Update call buttons in user list
  renderUsersList(userSearchInput.value);

  // NEW: SEND INCOMING CALL PUSH NOTIFICATION TO CALLEE
try {
  const messagePayload = {
  toUid,          // Callee's UID
  callId: callRef.id,
  fromName: myDisplayName || defaultNameFromEmail(emailInput?.value),
  note: note,
  timestamp: new Date().toLocaleString(), // Adding timestamp
  sentAtMs: Date.now(),  // Add the timestamp when the call was initiated
};

await sendIncomingCallNotification(messagePayload);


  // Trigger the push notification for incoming call
  await sendIncomingCallNotification(messagePayload);
} catch (e) {
  console.error("Error sending incoming call push notification:", e);
}

  // Watch the call doc for accepted/declined/ended/delivery/push status
  listenActiveCall(activeCallId);

  setStatus(dirCallStatus, `Calling ${toName || "user"}â€¦`);
  startRingback();
  logDiag(`Outgoing call created: ${callRef.id} roomId=${created.roomId}`);
  sendIncomingCallNotification({
    callId: callRef.id,    // the unique call identifier
    fromName: myDisplayName, // the caller's name
    toUid: toUid,           // the recipient's UID
    note: note,             // the optional note/message
    roomId: created.roomId, // the unique room ID
  });
   // Refresh calls list to show the new outgoing call
  try { await loadRecentCalls(); } catch {};

 // NEW: Function to send incoming call push notification
async function sendIncomingCallNotification(message) {
  try {
    const response = await fetch("/easosunov/sendIncomingPush", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(message),
    });

    if (!response.ok) {
      throw new Error("Failed to send incoming call push notification");
    }

    const data = await response.json();
    console.log("Incoming call push notification sent:", data);
  } catch (error) {
    console.error("Error sending incoming call notification:", error);
  }
}
}

/* ================== PUSH (optional) ================== */
let messaging = null;
let swReg = null;
/* ===== NEW: rotate FCM token when user changes on same browser ===== */
let lastPushUid = null;

async function rotateFcmTokenIfUserChanged(){
  try{
    if(!("Notification" in window)) return;
    if(!("serviceWorker" in navigator)) return;
    if(Notification.permission !== "granted") return;

    // If browser already had push for another user, invalidate token
    if(lastPushUid && myUid && lastPushUid !== myUid){
      logDiag(`Push: user changed ${lastPushUid} -> ${myUid}. Deleting old FCM token`);

      if(!messaging){
        messaging = getMessaging(app);
      }

      // IMPORTANT: this invalidates the token at FCM level
      await deleteToken(messaging);
      logDiag("Push: deleteToken() success");
    }

    lastPushUid = myUid || null;
  }catch(e){
    logDiag("rotateFcmTokenIfUserChanged failed: " + (e?.message || e));
  }
}
  // Remember which token belongs to THIS browser + which UID it was saved under
const LS_PUSH_UID = "webrtc_push_uid";
const LS_PUSH_TID = "webrtc_push_tokenId";

function getSavedPushBinding(){
  try{
    const uid = localStorage.getItem(LS_PUSH_UID);
    const tid = localStorage.getItem(LS_PUSH_TID);
    return { uid: uid || null, tokenId: tid || null };
  }catch{
    return { uid:null, tokenId:null };
  }
}

function savePushBinding(uid, tokenId){
  try{
    localStorage.setItem(LS_PUSH_UID, String(uid || ""));
    localStorage.setItem(LS_PUSH_TID, String(tokenId || ""));
  }catch{}
}

function clearPushBinding(){
  try{
    localStorage.removeItem(LS_PUSH_UID);
    localStorage.removeItem(LS_PUSH_TID);
  }catch{}
}

// Remove this browser's token doc from the PREVIOUS user's profile (and invalidate token)
async function revokePushForCurrentDevice(){
  const { uid, tokenId } = getSavedPushBinding();
  if(!uid || !tokenId) return;

  logDiag(`Revoking push token for this device: uid=${uid} tokenId=${tokenId}`);

  // Delete token doc from Firestore (stops server from targeting this browser)
  try{
    await deleteDoc(doc(db, "users", uid, "fcmTokens", tokenId));
    logDiag("Push token doc deleted from Firestore.");
  }catch(e){
    logDiag("Push token doc delete failed: " + (e?.message || e));
    // don't throw; continue
  }

  // Invalidate token in browser
  try{
    if(!messaging) messaging = getMessaging(app);
    await deleteToken(messaging);
    logDiag("Browser FCM token deleted (deleteToken).");
  }catch(e){
    logDiag("deleteToken failed: " + (e?.message || e));
  }

  clearPushBinding();
}

function base64UrlToUint8Array(base64Url) {
  const padding = "=".repeat((4 - (base64Url.length % 4)) % 4);
  const base64 = (base64Url + padding).replace(/-/g, "+").replace(/_/g, "/");
  const raw = atob(base64);
  const arr = new Uint8Array(raw.length);
  for (let i = 0; i < raw.length; i++) arr[i] = raw.charCodeAt(i);
  return arr;
}

function validateVapid(vapid) {
  const s = String(vapid || "").trim();
  if (!/^[A-Za-z0-9\-_]+$/.test(s)) return { ok:false, why:"contains invalid characters" };
  try {
    const bytes = base64UrlToUint8Array(s);
    if (bytes.length !== 65) return { ok:false, why:`decoded length ${bytes.length}, expected 65` };
    return { ok:true, why:`ok (65 bytes)` };
  } catch (e) {
    return { ok:false, why:`decode failed: ${e?.message || e}` };
  }
}

async function enablePush(){
  logDiag("enablePush(): ENTER");
  if(!requireAuthOrPrompt()) return;

// If this browser previously stored a token under a different UID, remove it first
const prev = getSavedPushBinding();
if(prev.uid && prev.uid !== myUid){
  await revokePushForCurrentDevice();
}

  
  if (!("Notification" in window)) { setStatus(pushStatus, "Push: not supported in this browser."); return; }
  if (!("serviceWorker" in navigator)) { setStatus(pushStatus, "Push: service worker not supported."); return; }
  if(!PUBLIC_VAPID_KEY || PUBLIC_VAPID_KEY.includes("PASTE_")) { setStatus(pushStatus, "Push: set PUBLIC_VAPID_KEY in HTML first."); return; }

  try {
    const swUrl = new URL("/easosunov/firebase-messaging-sw.js", location.origin);
    swUrl.searchParams.set("v", "2026-01-03-sw-note-ts-1");


    const resp = await fetch(swUrl.toString(), { cache: "no-store" });
    const ct = resp.headers.get("content-type") || "";
    const txt = await resp.text();
    logDiag("SW prefetch url=" + swUrl.toString());
    logDiag("SW prefetch status=" + resp.status + " content-type=" + ct);
    logDiag("SW prefetch first200=" + txt.slice(0, 200).replace(/\s+/g, " "));
    if (!resp.ok) throw new Error("SW fetch failed: " + resp.status);

    // Reuse bootstrap SW registration (do NOT register again)
    swReg = swBootstrapReg || await navigator.serviceWorker.getRegistration("/easosunov/");
    if (!swReg) throw new Error("Service worker not installed (bootstrap failed).");

    await navigator.serviceWorker.ready;
    try { await swReg.update(); } catch {}

    messaging = getMessaging(app);

    const perm = await Notification.requestPermission();
    if (perm !== "granted"){ setStatus(pushStatus, "Push: permission not granted."); return; }

    const check = validateVapid(VAPID);
    logDiag("VAPID check: " + check.ok + " - " + check.why);
    if (!check.ok) throw new Error("Invalid VAPID: " + check.why);

    const token = await getToken(messaging, {
      vapidKey: VAPID,
      serviceWorkerRegistration: swReg
    });

    if(!token){ setStatus(pushStatus, "Push: no token returned."); return; }

    const tokenId = token.slice(0, 32);

    await setDoc(doc(db, "users", myUid, "fcmTokens", tokenId), {
      token,
      createdAt: Date.now(),
      ua: navigator.userAgent,
      enabled: true
    }, { merge:true });
    
    // Remember that THIS browser token now belongs to THIS uid
    savePushBinding(myUid, tokenId);

    setStatus(pushStatus, "Push: enabled.");
    logDiag("FCM token stored (users/{uid}/fcmTokens).");

    onMessage(messaging, async (payload)=>{
      try{
        logDiag("FCM foreground message: " + JSON.stringify(payload));
        const data = payload?.data || {};

        // Must be signed in to react
        if(!isAuthed || !myUid) {
          logDiag("Ignoring FCM: not authed");
          return;
        }

        // If this is a call, verify it is REALLY for me by reading the call doc
        if (data.callId) {
          const callRef = doc(db, "calls", data.callId);
          const callSnap = await getDoc(callRef);
          if(!callSnap.exists()){
            logDiag("Ignoring FCM: call doc missing");
            return;
          }
          const call = callSnap.data() || {};

          if(call.toUid !== myUid){
            logDiag(`Ignoring FCM: call toUid=${call.toUid} does not match myUid=${myUid}`);
            return;
          }

          // OK - it is for me
          if (call.roomId) roomIdInput.value = call.roomId;
          currentIncomingCall = { id: data.callId, data: call };

          incomingText.textContent =
            payload?.notification?.body ||
            (call.fromName ? `Call from ${call.fromName}` : "Incoming callâ€¦");

          incomingOverlay.style.display = "flex";
          startRingtone();
          return;
        }

        // Non-call pushes: ignore (or handle if you want)
        logDiag("Ignoring FCM: not a callId payload");
      }catch(e){
        logDiag("onMessage handler error: " + (e?.message || e));
      }
    });

  } catch (e) {
    setStatus(pushStatus, "Push: failed (see diagnostics).");
    try { logDiag("Push error props: " + JSON.stringify(e, Object.getOwnPropertyNames(e))); } catch {}
    logDiag("Push enable failed: " + (e?.message || e));
    showError(e);
  }
}

let autoPushClickArmed = false;

function autoEnablePushOnLogin(){
  if (!("Notification" in window)) { setStatus(pushStatus, "Push: not supported in this browser."); return; }
  if (!("serviceWorker" in navigator)) { setStatus(pushStatus, "Push: service worker not supported."); return; }

  const perm = Notification.permission;

  if (perm === "granted") {
    logDiag("Auto-push: permission granted -> enabling push now");
    enablePush().catch((e)=> logDiag("Auto-push enable failed: " + (e?.message || e)));
    return;
  }

  if (perm === "denied") {
    setStatus(pushStatus, "Push: blocked in browser settings (Notifications = Block).");
    logDiag("Auto-push: permission denied");
    return;
  }

  setStatus(pushStatus, "Push: click anywhere once to enable notifications.");
  if (autoPushClickArmed) return;
  autoPushClickArmed = true;

  const handler = () => {
    autoPushClickArmed = false;
    logDiag("Auto-push: user click detected -> enabling push");
    enablePush().catch((e)=>{ logDiag("Auto-push enable failed: " + (e?.message || e)); showError(e); });
  };

  window.addEventListener("click", handler, { once:true, capture:true });
}

/* ================== BUTTON WIRING ================== */
startBtn.onclick = async ()=>{
  try{
    hideErrorBox();
    await startMedia();
  }catch(e){
    const name = String(e?.name || "");
    if(name === "NotAllowedError" || name === "NotFoundError") return;
    showError(e);
  }
};

createBtn.onclick = ()=> createRoom({updateHash:true, reuseRoomIdInput:true, fixedRoomId:null}).catch(showError);
joinBtn.onclick   = ()=> joinRoom().catch(showError);

roomIdInput.addEventListener("input", ()=> refreshCopyInviteState());
refreshCopyInviteState();

testSoundBtn.onclick = async ()=>{
  await unlockAudio();
  startRingtone();
  setTimeout(()=>stopRingtone(), 1800);
};

resetPushBtn.onclick = async ()=>{
  try{
    setStatus(pushStatus, "Push: resettingâ€¦");
    await revokePushForCurrentDevice();   // deletes token doc + deleteToken()
    await enablePush();                   // registers SW + gets fresh token + stores it
    setStatus(pushStatus, "Push: enabled (reset).");
  }catch(e){
    showError(e);
  }
};

/* Add this handler after the other button handlers: */
logoutUtilityBtn.onclick = async () => {
    if (!isAuthed) return;
    
    if (confirm("Are you sure you want to log out? Any active calls will be ended.")) {
        try {
            stopAll(); // stop listeners/media before auth changes
            await revokePushForCurrentDevice(); // remove token mapping for this browser
            await signOut(auth);
        } catch (e) {
            showError(e);
        }
    }
};
 
hangupBtn.onclick = ()=> hangup().catch(showError);

/* C-lite directory buttons */
saveNameBtn.onclick = ()=> saveMyName().catch(showError);
refreshUsersBtn.onclick = ()=> loadAllAllowedUsers().catch(showError);
myNameInput.addEventListener("input", ()=>{
  saveNameBtn.disabled = !isAuthed || !String(myNameInput.value||"").trim();
});
userSearchInput.addEventListener("input", ()=> renderUsersList(userSearchInput.value));

 /* ===== NEW: Phone dial restore handler ===== */
// This will be called from the dynamically created button
window.restorePhoneDial = function() {
  location.reload();
};

// Update the showEmailLoginBtn handler
if (showEmailLoginBtn) {
  showEmailLoginBtn.addEventListener('click', () => {
    if (!document.querySelector('#loginCard')) return;
    
    document.querySelector('#loginCard').innerHTML = `
      <button id="logoutBtn" style="display:none;">Logout</button>
      <h2 style="margin:0 0 20px;font-size:28px;text-align:center;">Email Sign In</h2>
      <div class="small" style="font-size:18px;text-align:center;margin-bottom:20px;">For administrators and email users</div>
      
      <div style="margin:20px 0;">
        <div style="font-size:20px;margin-bottom:8px;font-weight:bold;">Email Address</div>
        <input id="emailInput" type="email" placeholder="your.email@example.com" autocomplete="username" style="font-size:22px;padding:16px;width:100%;border-radius:12px;border:2px solid #1976d2;"/>
      </div>
      
      <div style="margin:20px 0;">
        <div style="font-size:20px;margin-bottom:8px;font-weight:bold;">Password</div>
        <input id="passInput" type="password" placeholder="Enter your password" autocomplete="current-password" style="font-size:22px;padding:16px;width:100%;border-radius:12px;border:2px solid #1976d2;"/>
      </div>
      
      <button id="loginBtn" style="font-size:24px;padding:18px;background:#1976d2;color:white;border:none;border-radius:12px;width:100%;margin:10px 0;cursor:pointer;">
        Sign In with Email
      </button>
      
      <div id="loginStatus" style="font-size:18px;text-align:center;margin:20px 0;min-height:30px;color:#666;">
        Enter your email and password
      </div>
      
      <div style="margin-top:25px;border-top:1px solid #eee;padding-top:20px;">
        <button id="showPhoneLoginBtn" style="font-size:18px;padding:14px;background:#f5f5f5;border:2px solid #ddd;color:#666;width:100%;border-radius:12px;cursor:pointer;">
          â† Back to Phone Dial
        </button>
      </div>
    `;
    
    setTimeout(() => {
      const showPhoneLoginBtn = document.getElementById('showPhoneLoginBtn');
      const loginBtn = document.getElementById('loginBtn');
      const emailInput = document.getElementById('emailInput');
      
      if (showPhoneLoginBtn) {
        showPhoneLoginBtn.addEventListener('click', () => {
          location.reload();
        });
      }
      
      if (loginBtn) {
        loginBtn.addEventListener('click', handleEmailLogin);
      }
      
      if (emailInput) {
        emailInput.focus();
      }
    }, 100);
  });
}

/* Calls list button */
refreshCallsBtn.onclick = ()=> loadRecentCalls().catch(showError);

/* ================== UID allowlist ================== */
async function enforceAllowlist(user){
  const uid = user.uid;
  logDiag("Allowlist check uid=" + uid);

  try{
    const ref = doc(db, "allowlistUids", uid);
    const snap = await getDoc(ref);

    if(!snap.exists()){
      if(loginStatus) loginStatus.textContent = "Not approved yet. Your UID: " + uid;
      try{ await signOut(auth); }catch{}
      throw new Error("Allowlist missing for UID: " + uid);
    }

    const enabled = snap.data()?.enabled === true;
    if(!enabled){
      if(loginStatus) loginStatus.textContent = "Not approved yet (enabled=false). Your UID: " + uid;
      try{ await signOut(auth); }catch{}
      throw new Error("Allowlist disabled for UID: " + uid);
    }

    return true;
  }catch(e){
    if(String(e?.code || "").includes("permission-denied")){
      if(loginStatus) {
        loginStatus.textContent =
          "Allowlist check blocked by Firestore rules (permission-denied).";
      }
    }
    throw e;
  }
}

 
/* ================== BACKGROUND SERVICE ================== */
// Test if background service is running
async function checkBackgroundService() {
  try {
    const response = await fetch('http://localhost:3000/status', { 
      method: 'GET',
      headers: { 'Content-Type': 'application/json' }
    });
    const data = await response.json();
    return data;
  } catch (error) {
    // Service is not running or not reachable
    return { isRunning: false, uid: null };
  }
}

// Start background service
async function startBackgroundService() {
  if (!isAuthed || !myUid) {
    alert('Please sign in first');
    return;
  }
  
  try {
    bgStatus.textContent = 'Connecting to background service...';
    
    const response = await fetch('http://localhost:3000/start', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        uid: myUid
      })
    });
    
    const data = await response.json();
    
    if (data.success) {
      bgStatus.textContent = 'âœ… Background service active';
      startBgBtn.disabled = true;
      stopBgBtn.disabled = false;
      logDiag('Background service started for UID: ' + myUid);
    } else {
      throw new Error(data.error || 'Failed to start');
    }
  } catch (error) {
    bgStatus.textContent = 'âŒ Failed to connect';
    logDiag('Background service error: ' + error.message);
    
    // Show helpful message
    if (error.message.includes('fetch') || error.message.includes('network')) {
      alert('Background app is not running. Please:\n1. Make sure webrtc-notifier.exe is running\n2. Check system tray for the icon\n3. Try starting it manually from the webrtc-notifier-win32-x64 folder');
    }
  }
}

// Stop background service
async function stopBackgroundService() {
  try {
    const response = await fetch('http://localhost:3000/stop', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    });
    
    const data = await response.json();
    
    if (data.success) {
      bgStatus.textContent = 'Background service stopped';
      startBgBtn.disabled = false;
      stopBgBtn.disabled = true;
      logDiag('Background service stopped');
    }
  } catch (error) {
    logDiag('Error stopping background service: ' + error.message);
  }
}

// Update service status
async function updateServiceStatus() {
  if (isAuthed) {
    startBgBtn.disabled = false;
    
    try {
      const status = await checkBackgroundService();
      if (status.isRunning && status.uid === myUid) {
        bgStatus.textContent = 'âœ… Background service active';
        startBgBtn.disabled = true;
        stopBgBtn.disabled = false;
      } else {
        bgStatus.textContent = 'Background service ready';
        stopBgBtn.disabled = true;
      }
    } catch (error) {
      bgStatus.textContent = 'Background app not detected';
      stopBgBtn.disabled = true;
    }
  } else {
    startBgBtn.disabled = true;
    stopBgBtn.disabled = true;
    bgStatus.textContent = 'Sign in required';
  }
}

// Event listeners
startBgBtn.onclick = startBackgroundService;
stopBgBtn.onclick = stopBackgroundService;

// Download link
// Download link - remove onclick handler since href is already set
// Or update to use your GitHub URL
downloadBgLink.onclick = (e) => {
  // Optional: Add analytics or confirmation
  console.log('Downloading background app...');
  // Let the default link behavior happen (browser will download)
};

/* ================== SINGLE USER PER COMPUTER (cross-tab) ================== */
const DEVICE_OWNER_KEY = "webrtc_device_owner_uid";
const DEVICE_OWNER_AT  = "webrtc_device_owner_at";

const hasBroadcastChannel = ("BroadcastChannel" in window);
const authBC = hasBroadcastChannel ? new BroadcastChannel("webrtc_auth_channel") : null;

function nowMs(){ return Date.now(); }

function setDeviceOwner(uid){
  try{
    localStorage.setItem(DEVICE_OWNER_KEY, String(uid || ""));
    localStorage.setItem(DEVICE_OWNER_AT, String(nowMs()));
  }catch{}
}

function clearDeviceOwner(){
  try{
    localStorage.removeItem(DEVICE_OWNER_KEY);
    localStorage.removeItem(DEVICE_OWNER_AT);
  }catch{}
}

function getDeviceOwner(){
  try{
    return String(localStorage.getItem(DEVICE_OWNER_KEY) || "").trim() || null;
  }catch{
    return null;
  }
}

async function forceSignOutBecauseDifferentUser(newUid){
  // If this tab is signed in as someone else, sign out immediately.
  const currentUid = auth.currentUser?.uid || null;
  if (currentUid && newUid && currentUid !== newUid){
    logDiag(`Single-user lock: another user (${newUid}) logged in on this computer -> signing out ${currentUid} in this tab`);
    try{
      stopAll(); // stop listeners/media before auth changes
    }catch{}
    try{
      await signOut(auth);
    }catch(e){
      // If signOut fails, still show why
      showError(e);
    }
  }
}

function broadcastNewOwner(uid){
  if(authBC){
    try{ authBC.postMessage({ type:"NEW_OWNER", uid, at: nowMs() }); }catch{}
  }
}

// Listen for owner changes via BroadcastChannel
if(authBC){
  authBC.onmessage = (ev)=>{
    const msg = ev?.data || {};
    if(msg.type === "NEW_OWNER" && msg.uid){
      forceSignOutBecauseDifferentUser(String(msg.uid));
    }
    if(msg.type === "OWNER_CLEARED"){
      // nothing required
    }
  };
}
// Listen for focus requests from duplicate tabs
if (hasBroadcastChannel) {
  const focusChannel = new BroadcastChannel("webrtc_focus_request");
  focusChannel.onmessage = (ev) => {
    const msg = ev?.data || {};
    if (msg.type === "FOCUS_REQUEST" && msg.fromTab !== tabId) {
      // This is the original tab - bring it to front
      window.focus();
      if (document.hidden) {
        // Try to make browser bring tab to front (may not work due to browser restrictions)
        console.log("Focus requested by duplicate tab");
      }
    }
  };
}
/* ================== SINGLE PAGE INSTANCE LOCK ================== */
const PAGE_INSTANCE_KEY = "webrtc_single_page_instance";
const PAGE_INSTANCE_TIMESTAMP = "webrtc_page_instance_ts";
const PAGE_INSTANCE_ACTIVE_CHECK = "webrtc_page_active_check";

// Generate unique tab ID
const tabId = Math.random().toString(36).substring(2) + Date.now().toString(36);
let hasLock = false;
let lockCheckInterval = null;
let isDisabled = false;

// Function to IMMEDIATELY disable the app
function disableAppImmediately() {
  if (isDisabled) return;
  isDisabled = true;
  
  logDiag("IMMEDIATE DISABLE: Another instance detected");
  
  // Stop all media and connections
  stopAll();
  
  // Disable UI
  if (appRoot) {
    appRoot.classList.add('locked');
    appRoot.style.pointerEvents = 'none';
    appRoot.style.opacity = '0.5';
  }
  
  // Hide login overlay if visible
  if (loginOverlay) {
    loginOverlay.style.display = 'none';
  }
  
  // Instead of showing a blocking overlay, redirect user to focus on the existing tab
  // by closing this tab/window and focusing the original one
  
  // Try to close this tab/window
  try {
    // Try to find and focus the original tab by broadcasting a message
    if (hasBroadcastChannel) {
      const focusChannel = new BroadcastChannel("webrtc_focus_request");
      focusChannel.postMessage({ type: "FOCUS_REQUEST", fromTab: tabId });
      setTimeout(() => {
        focusChannel.close();
      }, 1000);
    }
    
    // Close this tab after a short delay
    setTimeout(() => {
      if (window.history.length > 1) {
        window.history.back();
      } else {
        window.close();
      }
    }, 100);
    
  } catch (e) {
    // If we can't close, show a minimal message and redirect to about:blank
    console.log("Another instance is already running");
    window.location.href = "about:blank";
  }
  
  // Add button hover effects
  const buttons = blocker.querySelectorAll('button');
  buttons.forEach(btn => {
    btn.addEventListener('mouseenter', () => {
      if (btn.id === 'closePageBtn') {
        btn.style.background = '#ff5252';
      } else if (btn.id === 'goBackBtn') {
        btn.style.background = '#5a6573';
      } else if (btn.id === 'reloadBtn') {
        btn.style.background = 'rgba(255, 255, 255, 0.1)';
        btn.style.color = '#ddd';
      }
    });
    btn.addEventListener('mouseleave', () => {
      if (btn.id === 'closePageBtn') {
        btn.style.background = '#ff6b6b';
      } else if (btn.id === 'goBackBtn') {
        btn.style.background = '#4a5568';
      } else if (btn.id === 'reloadBtn') {
        btn.style.background = 'transparent';
        btn.style.color = '#aaa';
      }
    });
  });
  
  // Add button handlers
  document.getElementById('goBackBtn')?.addEventListener('click', () => {
    if (window.history.length > 1) {
      window.history.back();
    } else {
      // If no history, redirect to a blank page or previous page
      window.location.href = 'about:blank';
    }
  });
  
  document.getElementById('closePageBtn')?.addEventListener('click', () => {
    // Try multiple methods to close or navigate away
    try {
      // Method 1: Try to close (works for popup windows)
      if (window.opener || window.history.length <= 1) {
        window.close();
      } else {
        // Method 2: For regular tabs, navigate to blank page
        window.location.href = 'about:blank';
        // Method 3: Try to close after a delay
        setTimeout(() => {
          try { window.close(); } catch(e) {}
        }, 100);
      }
    } catch (e) {
      // Method 4: If close fails, navigate to previous page or blank
      if (window.history.length > 1) {
        window.history.go(-1);
      } else {
        window.location.href = 'about:blank';
      }
    }
  });
  
  document.getElementById('reloadBtn')?.addEventListener('click', () => {
    // First clear the lock so we can try to acquire it again
    try {
      localStorage.removeItem(PAGE_INSTANCE_KEY);
      localStorage.removeItem(PAGE_INSTANCE_TIMESTAMP);
      localStorage.removeItem(PAGE_INSTANCE_ACTIVE_CHECK);
    } catch (e) {}
    
    // Remove blocker and reload
    blocker.remove();
    isDisabled = false;
    setTimeout(() => {
      window.location.reload();
    }, 300);
  });
}

// Function to check and acquire lock - STRICTER VERSION
function checkAndAcquireLock() {
  try {
    const now = Date.now();
    const storedLock = localStorage.getItem(PAGE_INSTANCE_KEY);
    const storedTimestamp = localStorage.getItem(PAGE_INSTANCE_TIMESTAMP);
    const lockTime = storedTimestamp ? parseInt(storedTimestamp, 10) : 0;
    const lockAge = now - lockTime;
    
    // CRITICAL: If lock exists and is less than 10 seconds old, reject immediately
    if (storedLock && storedLock !== tabId && lockAge < 10000) {
      logDiag(`LOCK REJECTED: Tab ${storedLock} has active lock (age: ${lockAge}ms)`);
      return false;
    }
    
    // Clear any stale lock (older than 10 seconds)
    if (lockAge >= 10000) {
      logDiag(`Clearing stale lock from tab ${storedLock} (age: ${lockAge}ms)`);
      localStorage.removeItem(PAGE_INSTANCE_KEY);
      localStorage.removeItem(PAGE_INSTANCE_TIMESTAMP);
      localStorage.removeItem(PAGE_INSTANCE_ACTIVE_CHECK);
    }
    
    // Acquire the lock
    localStorage.setItem(PAGE_INSTANCE_KEY, tabId);
    localStorage.setItem(PAGE_INSTANCE_TIMESTAMP, now.toString());
    localStorage.setItem(PAGE_INSTANCE_ACTIVE_CHECK, now.toString());
    hasLock = true;
    
    logDiag(`LOCK ACQUIRED by tab ${tabId}`);
    return true;
    
  } catch (e) {
    logDiag("Lock acquisition error: " + e.message);
    return false; // Be strict if localStorage fails
  }
}

// Function to renew our lock and check for conflicts
function renewAndCheckLock() {
  if (!hasLock || isDisabled) return false;
  
  try {
    const now = Date.now();
    const storedLock = localStorage.getItem(PAGE_INSTANCE_KEY);
    const storedTimestamp = localStorage.getItem(PAGE_INSTANCE_TIMESTAMP);
    const lockTime = storedTimestamp ? parseInt(storedTimestamp, 10) : 0;
    
    // If we don't own the lock anymore, DISABLE IMMEDIATELY
    if (storedLock !== tabId) {
      logDiag(`LOCK STOLEN: Tab ${storedLock} now owns the lock`);
      disableAppImmediately();
      return false;
    }
    
    // If lock is stale (older than 30 seconds), someone else might have taken it
    const lockAge = now - lockTime;
    if (lockAge > 30000) {
      logDiag(`LOCK STALE: Our lock is ${lockAge}ms old - possible conflict`);
      // Try to reacquire
      if (!checkAndAcquireLock()) {
        disableAppImmediately();
        return false;
      }
    }
    
    // Renew our lock
    localStorage.setItem(PAGE_INSTANCE_TIMESTAMP, now.toString());
    localStorage.setItem(PAGE_INSTANCE_ACTIVE_CHECK, now.toString());
    return true;
    
  } catch (e) {
    logDiag("Lock renewal error: " + e.message);
    return false;
  }
}

// Function to release our lock
function releaseLock() {
  if (hasLock) {
    try {
      const currentLock = localStorage.getItem(PAGE_INSTANCE_KEY);
      if (currentLock === tabId) {
        localStorage.removeItem(PAGE_INSTANCE_KEY);
        localStorage.removeItem(PAGE_INSTANCE_TIMESTAMP);
        localStorage.removeItem(PAGE_INSTANCE_ACTIVE_CHECK);
        logDiag(`Lock released by tab ${tabId}`);
      }
    } catch (e) {
      // Ignore errors if already updated above
    }
    hasLock = false;
  }
}

// Initialize lock on page load - DO THIS EARLY
(function initializeLock() {
  // Try to acquire lock immediately
  if (!checkAndAcquireLock()) {
    logDiag("Failed to acquire lock on initialization");
    setTimeout(disableAppImmediately, 100);
    return;
  }
  
  // Start aggressive lock checking
  lockCheckInterval = setInterval(() => {
    if (document.visibilityState === 'visible') {
      if (!renewAndCheckLock()) {
        clearInterval(lockCheckInterval);
      }
    }
  }, 1000); // Check every second when visible
  
  // Also check when page becomes visible
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      // Page hidden - reduce checking frequency
      if (lockCheckInterval) {
        clearInterval(lockCheckInterval);
        lockCheckInterval = setInterval(() => {
          if (!renewAndCheckLock()) {
            clearInterval(lockCheckInterval);
          }
        }, 3000); // Check every 3 seconds when hidden
      }
    } else {
      // Page visible - check immediately and frequently
      if (lockCheckInterval) {
        clearInterval(lockCheckInterval);
      }
      if (!renewAndCheckLock()) {
        return;
      }
      lockCheckInterval = setInterval(() => {
        if (!renewAndCheckLock()) {
          clearInterval(lockCheckInterval);
        }
      }, 1000);
    }
  });
  
  // Listen for storage events (other tabs changing localStorage)
  window.addEventListener('storage', (event) => {
    if (event.key === PAGE_INSTANCE_KEY && event.newValue && event.newValue !== tabId) {
      logDiag(`Storage event: Another tab (${event.newValue}) set the lock`);
      setTimeout(() => {
        if (!renewAndCheckLock()) {
          disableAppImmediately();
        }
      }, 100);
    }
  });  // <-- This should be just one closing brace and one closing parenthesis
  
  // Beforeunload cleanup
  window.addEventListener('beforeunload', () => {
    if (lockCheckInterval) {
      clearInterval(lockCheckInterval);
      lockCheckInterval = null;
    }
    releaseLock();
  });
  
  // Double-check after a short delay
  setTimeout(() => {
    if (!renewAndCheckLock()) {
      disableAppImmediately();
    }
  }, 2000);
})();  // <-- This closes the entire IIFE

 /* ================== AUTH GATE ================== */
function requireAuthOrPrompt(){
  if (isAuthed) return true;
  // Don't show login overlay here - let the auth state handler manage it
  return false;
}


// SIMPLIFIED LOGIN BUTTON HANDLER - FIXED VERSION
loginBtn.onclick = async () => {
  hideErrorBox();
  
  // Check if we're in phone dial mode or email mode
  const isPhoneDialMode = document.querySelector('.dial-btn') !== null;
  
  if (isPhoneDialMode) {
    // PHONE DIAL LOGIN
    if (loginStatus) loginStatus.textContent = "Checking phone numberâ€¦";
    wasManualLogin = true;
    
    try {
      // Get the dialed number - store it for Firestore submission
      const phoneNumber = window.dialedNumber || dialedNumber;
      window.submittedPhoneNumber = phoneNumber; // Store for authentication
      
      if (loginStatus) loginStatus.textContent = "Verifying phone numberâ€¦";
      
      // First check if phone number is allowed
      const phoneCheck = await isPhoneNumberAllowed(phoneNumber);
      
      if (!phoneCheck.allowed) {
        if (loginStatus) loginStatus.textContent = "Phone number not registered";
        logDiag(`Phone auth failed: ${phoneNumber} not in allowlist`);
        return;
      }
      
      // Try phone authentication
      if (loginStatus) loginStatus.textContent = "Signing in with phoneâ€¦";
      
      try {
        const authResult = await signInWithPhoneNumber(phoneNumber);
        
        if (authResult.success) {
          // Success! Phone authentication worked
          if (loginStatus) loginStatus.textContent = "Signed in successfully!";
          logDiag(`Phone authentication successful for: ${phoneNumber}`);
          
          // Claim device owner
          const uid = auth.currentUser?.uid;
          if (uid) {
            setDeviceOwner(uid);
            broadcastNewOwner(uid);
          }
          
          return; // Authentication complete
        }
        
        // If authentication requires email/password
        if (authResult.requiresEmail && authResult.email) {
          if (loginStatus) loginStatus.textContent = "Phone verified. Enter passwordâ€¦";
          // Show email/password form with pre-filled email
          showEmailLoginForm(authResult.email, phoneNumber);
        } else {
          if (loginStatus) loginStatus.textContent = authResult.message || "Authentication failed";
        }
        
      } catch (error) {
        if (loginStatus) loginStatus.textContent = `Login failed: ${error.message || "unknown error"}`;
        logDiag("Phone login error: " + (error?.message || error));
        showError(error);
      }
      
    } catch (e) {
      if (loginStatus) loginStatus.textContent = `Login failed: ${e?.message || "unknown error"}`;
      logDiag("Phone login error: " + (e?.message || e));
      showError(e);
    }
    
  } else {
    // EMAIL/PASSWORD LOGIN (fallback mode)
    if (loginStatus) loginStatus.textContent = "Signing inâ€¦";
    wasManualLogin = true;
    
    try {
      const email = emailInput?.value.trim();
      const password = passInput?.value;
      
      if (!email || !password) {
        if (loginStatus) loginStatus.textContent = "Please enter email and password";
        return;
      }
      
      await signInWithEmailAndPassword(auth, email, password);
      if (loginStatus) loginStatus.textContent = "Signed in. Checking allowlistâ€¦";

      // Claim device owner immediately
      const uid = auth.currentUser?.uid;
      if(uid){
        setDeviceOwner(uid);
        broadcastNewOwner(uid);
      }

    } catch (e) {
      if (loginStatus) loginStatus.textContent = `Login failed: ${e?.code || "unknown"}`;
      try { logDiag("LOGIN ERROR PROPS: " + JSON.stringify(e, Object.getOwnPropertyNames(e))); } catch {}
      showError(e);
    }
  }
};

logoutBtn.onclick = async () => {
  try{
    stopAll();                 // stop listeners/media/UI
    await revokePushForCurrentDevice(); // <-- remove token mapping for this browser
    await signOut(auth);
  }catch(e){
    showError(e);
  }
};

/* ================== AUTH STATE ================== */
onAuthStateChanged(auth, async (user)=>{
  // First, attempt Android phone auto-login before processing auth state
  if (!isAutoLoginAttempted) {
    await attemptPhoneNumberAutoLogin();
  }
  
  isAuthed = !!user;
  myUid = user?.uid || null;
  logDiag(isAuthed ? "Auth: signed in" : "Auth: signed out");

  if (isAuthed){
    try{ await enforceAllowlist(user); }
    catch(e){
      showError(e);

      // restore locked UI so login doesn't look frozen
      loginOverlay.style.display = "flex";
      appRoot.classList.add("locked");
      logoutBtn.style.display = "none";
      startBtn.disabled = true;

      return;
    }

    // Single-user lock: reaffirm ownership after allowlist passes
    setDeviceOwner(user.uid);
    broadcastNewOwner(user.uid);

    // Hide login overlay if this was a manual login
    if (wasManualLogin) {
      loginOverlay.style.display = "none";
      appRoot.classList.remove("locked");
      wasManualLogin = false;
    } else {
      // Auto-authenticated - still allow access
      loginOverlay.style.display = "none";
      appRoot.classList.remove("locked");
    }
    
    logoutBtn.style.display = "inline-block";
    if (loginStatus) loginStatus.textContent = "Signed in.";

    startBtn.disabled = false;
    setStatus(mediaStatus, "Ready. Click Start to enable camera/mic.");

    // ===== NEW: enable quality selector once authed =====
    videoQualitySelect.disabled = false;
    updateVideoQualityUi();

    // ===== NEW: enable call mode radio buttons once authed =====
    testSoundBtn.disabled = false;
    resetPushBtn.disabled = false;

    await rotateFcmTokenIfUserChanged();
    autoEnablePushOnLogin();

    saveNameBtn.disabled = !String(myNameInput.value||"").trim();
    refreshUsersBtn.disabled = false;

    /* ADD THIS LINE: Show utility logout button when signed in */
    if (logoutUtilityBtn) {
        logoutUtilityBtn.style.display = "inline-block";
        logoutUtilityBtn.disabled = false;
    }
    
    hangupBtn.disabled = true;
    hangupBtn.className = "hangup-btn-inactive";

    refreshCopyInviteState();

    try{ await listenIncomingCalls(); } catch(e){ logDiag("Incoming listener failed: " + (e?.message || e)); }
    await catchUpMissedRingingCall();
    await catchUpMissedCallNotification();
    try{ await ensureMyUserProfile(user); } catch(e){ logDiag("ensureMyUserProfile failed: " + (e?.message || e)); }
    try{ await loadAllAllowedUsers(); } catch(e){ logDiag("loadAllAllowedUsers failed: " + (e?.message || e)); }
    try{ await loadRecentCalls(); } catch(e){ logDiag("loadRecentCalls failed: " + (e?.message || e)); }
    // Process any pending notifications after auth
    await processPendingNotifications();
    
    // Update user info with phone/email badge
    updateUserInfo();

    if (pendingIncomingCallWhileLoggedOut?.id) {
      const callId = pendingIncomingCallWhileLoggedOut.id;
      updateDoc(doc(db,"calls", callId), {
        deliveredAt: serverTimestamp(),
        deliveredVia: "push_open"
      }).catch(()=>{});
    }

    // Update background service status
    updateServiceStatus();
    setInterval(updateServiceStatus, 30000); // Check every 30 seconds

    window.addEventListener("click", () => startMedia().catch(()=>{}), { once:true });

  } else {
    // If we have Android phone login but no Firebase user, handle it
    if (isAndroidPhoneLogin && !user) {
      await handleAndroidPhoneAuthentication();
      return;
    }
    
    // Show phone dial interface by default for elderly users
    loginOverlay.style.display = "flex";
    appRoot.classList.add("locked");
    logoutBtn.style.display = "none";
    stopAll();
   
    // ===== NEW: lock quality selector when signed out =====
    if(videoQualitySelect) videoQualitySelect.disabled = true;

    
    testSoundBtn.disabled = true;
    resetPushBtn.disabled = true;

    saveNameBtn.disabled = true;
    refreshUsersBtn.disabled = true;

    /* Hide utility logout button when signed out */
    if (logoutUtilityBtn) {
        logoutUtilityBtn.style.display = "none";
        logoutUtilityBtn.disabled = true;
    }
    
    setStatus(pushStatus, "Push: not enabled.");
    setStatus(dirCallStatus, "Idle.");
    myNameStatus.textContent = "Not set.";

    bgStatus.textContent = 'Sign in required';
    startBgBtn.disabled = true;
    stopBgBtn.disabled = true;

    usersList.innerHTML = "";
    allUsersCache = [];
    myDisplayName = "";
    currentCalleeUid = null;
    userPhone = '';
    isAndroidPhoneLogin = false;
    
    // ===== NEW: Initialize phone dial interface =====
    // Ensure phone dial elements are properly initialized
    setTimeout(() => {
      if (phoneDisplay && dialedNumber) {
        phoneDisplay.textContent = dialedNumber;
      }
    }, 100);
  }
   
});

window.addEventListener("beforeunload", ()=>{
  try{ closePeer(); }catch{}
  try{ stopRingtone(); }catch{}
});

 
// ================== MAKE FCM FUNCTION GLOBALLY AVAILABLE ==================
// Wait for the module to load, then expose the function globally
(async function exposeFCMFunction() {
  // Wait a bit to ensure the module is loaded
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Check if the function exists in module scope
  if (typeof sendFCMToAndroid === 'function') {
    window.sendFCMToAndroid = sendFCMToAndroid;
    console.log("[FCM] Function exposed globally");
  } else {
    console.error("[FCM] Function not found in module");
    
    // Create a fallback global function
    window.sendFCMToAndroid = async function(toUid, roomId, callerName, note, callId) {
      console.log("[FCM FALLBACK] Using fallback function");
      
      try {
        // Get Android token
        const userDoc = await getDoc(doc(db, "users", toUid));
        if (!userDoc.exists()) {
          console.log("[FCM] Android user not found");
          return;
        }
        
        const fcmToken = userDoc.data()?.fcmToken;
        if (!fcmToken) {
          console.log("[FCM] No FCM token");
          return;
        }
        
        console.log("[FCM] Sending to Android token:", fcmToken.substring(0, 20) + "...");
        
        await fetch("https://us-central1-easosunov-webrtc.cloudfunctions.net/notifyIncomingCall", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            fcmToken: fcmToken,
            roomId: roomId,
            callerName: callerName,
            note: note || "",
            callId: callId,
            toUid: toUid
          })
        });
        
        console.log("[FCM] Notification sent");
      } catch (error) {
        console.error("[FCM] Error:", error);
      }
    };
    console.log("[FCM] Created fallback function");
  }
})(); 
</script>
</body>
</html>
