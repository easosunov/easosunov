<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>WebRTC</title>
<link rel="manifest" href="manifest.json">

<style>
/* ... (keep all your existing CSS styles exactly as they are) ... */
</style>
</head>

<body>
<!-- ... (keep all your existing HTML structure exactly as it is) ... -->

<script type="module">
console.log("APP VERSION:", "2026-01-17-android-windows-fix");

// ========== CRITICAL FIX: DETECT NOTIFICATION SOURCE ==========
console.log('=== PAGE OPEN DEBUG ===');
console.log('Full URL:', window.location.href);
console.log('Hash:', window.location.hash);
console.log('Search:', window.location.search);
console.log('Referrer:', document.referrer);
console.log('=== END DEBUG ===');

// Track if we showed a notification (for background app coordination)
let webPageShowedNotification = false;

// Handle notification redirects - UPDATED TO DETECT SOURCE
(function handleNotificationRedirect() {
  try {
    const urlParams = new URLSearchParams(window.location.search);
    const callId = urlParams.get('callId');
    const roomId = urlParams.get('roomId');
    const fromName = urlParams.get('fromName');
    const source = urlParams.get('source'); // 'android' or 'windows'
    
    // Store for later use when user signs in
    if (callId && roomId) {
      localStorage.setItem('pendingNotificationCall', JSON.stringify({
        callId: callId,
        roomId: roomId,
        fromName: fromName || 'Unknown',
        source: source || 'unknown',
        timestamp: Date.now()
      }));
      
      // SET CRITICAL FLAG: Page opened from notification
      localStorage.setItem('pageOpenedFromNotification', 'true');
      localStorage.setItem('notificationSource', source || 'unknown');
      
      // Clear URL parameters but KEEP THE HASH
      const cleanUrl = window.location.origin + window.location.pathname;
      window.history.replaceState({}, document.title, cleanUrl + window.location.hash);
      
      console.log('Notification stored. Source:', source, 'Flag set to prevent auto-join');
    } else if (location.hash.length > 1 && !location.search.includes('callId')) {
      // Windows listener opens with just hash, no query params
      localStorage.setItem('pageOpenedFromNotification', 'false');
      localStorage.setItem('notificationSource', 'windows');
      console.log('Windows listener opened page (hash only)');
    }
  } catch (e) {
    console.warn('Notification redirect handler error:', e);
  }
})();

// ========== AUTO-JOIN FIX ==========
// Add these flags at the TOP level
let pageOpenedFromNotification = localStorage.getItem('pageOpenedFromNotification') === 'true';
let notificationSource = localStorage.getItem('notificationSource') || '';

// Clear flags after we've read them (so they don't persist)
if (pageOpenedFromNotification) {
  console.log('Page was opened from notification. Source:', notificationSource);
  // Don't clear immediately - we need them for auto-join decision
}

// ========== MODIFIED AUTO-JOIN LOGIC ==========
let autoJoinDone = false;
let autoJoinScheduled = false;
let autoJoinTimer = null;

async function autoJoinIfNeeded(){
  // CRITICAL FIX: Check if page was opened from notification
  const openedFromNotification = localStorage.getItem('pageOpenedFromNotification') === 'true';
  const source = localStorage.getItem('notificationSource');
  
  if (openedFromNotification) {
    console.log('ðŸš« BLOCKING auto-join: Page opened from', source, 'notification');
    
    // Only clear flags after we've checked them
    localStorage.removeItem('pageOpenedFromNotification');
    localStorage.removeItem('notificationSource');
    
    // Show Accept/Decline buttons instead of auto-joining
    const roomId = location.hash.substring(1);
    if (roomId) {
      roomIdInput.value = roomId;
      console.log('Room ID from hash:', roomId);
      
      // Check if we have pending notification data
      const pending = localStorage.getItem('pendingNotificationCall');
      if (pending) {
        try {
          const pendingData = JSON.parse(pending);
          if (isAuthed && myUid) {
            showIncomingUI(pendingData.callId, {
              roomId: pendingData.roomId,
              fromName: pendingData.fromName || 'Unknown',
              source: pendingData.source
            });
          }
        } catch (e) {
          console.warn('Error processing pending notification:', e);
        }
      }
    }
    
    return; // STOP HERE - don't auto-join
  }
  
  // Normal auto-join logic (for Windows listener or direct link)
  if(autoJoinDone) return;
  if(!roomIdInput.value.trim()) return;

  autoJoinDone = true;
  setStatus(callStatus,"Auto-joining roomâ€¦");
  logDiag("Auto-joining triggered.");

  try{
    await joinRoom();
  }catch(e){
    autoJoinDone = false;
    throw e;
  }
}

// ========== MODIFIED DECLINE BUTTON HANDLER ==========
// In your existing declineBtn.onclick, ADD THIS at the beginning:
declineBtn.onclick = async ()=>{
  try{
    // CLEAR NOTIFICATION FLAGS when user clicks Decline
    localStorage.removeItem('pageOpenedFromNotification');
    localStorage.removeItem('notificationSource');
    localStorage.removeItem('pendingNotificationCall');
    
    const call = currentIncomingCall;
    stopIncomingUI();

    if(!call) return;

    const { id } = call;
    await updateDoc(doc(db,"calls", id), {
      status: "declined",
      declinedAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });

    // Clear notification flag
    webPageShowedNotification = false;
    localStorage.removeItem('pendingNotificationCall');

    setStatus(dirCallStatus, "Declined incoming call.");
    try { await listenIncomingCalls(); } catch {}
    try { await loadRecentCalls(); } catch {}
  }catch(e){
    showError(e);
  }
};

// ========== MODIFIED ACCEPT BUTTON HANDLER ==========
// In your existing answerBtn.onclick, ADD THIS at the beginning:
answerBtn.onclick = async ()=>{
  try{
    // CLEAR NOTIFICATION FLAGS when user clicks Accept
    localStorage.removeItem('pageOpenedFromNotification');
    localStorage.removeItem('notificationSource');
    localStorage.removeItem('pendingNotificationCall');
    
    const call = currentIncomingCall;
    stopIncomingUI();

    if(!call){
      setStatus(dirCallStatus, "No call context. Please wait for the caller again.");
      return;
    }

    const { id, data } = call;
    
    // ... rest of your existing Accept button code ...
  } catch(e) {
    showError(e);
  }
};

// ========== SW BOOTSTRAP (keep as is) ==========
let swBootstrapReg = null;
async function ensureServiceWorkerInstalled() {
  // ... keep your existing SW code ...
}

await ensureServiceWorkerInstalled();

/* ======== CONFIG ======== */
const PUBLIC_VAPID_KEY = "BCR4B8uf0WzUuzHKlBCJO22NNnnupe88j8wkjrTwwQALDpWUeJ3umtIkNJTrLb0I_LeIeu2HyBNbogHc6Y7jNzM";
function cleanVapidKey(k){
  return String(k || "").trim().replace(/[\r\n\s]/g, "");
}
const VAPID = cleanVapidKey(PUBLIC_VAPID_KEY);

/* ================== ELEMENTS ================== */
// ... (keep all your existing element definitions) ...

/* ================== STATE VARIABLES ================== */
let isAuthed = false;
let myUid = null;
let wasManualLogin = false;
let pendingIncomingCallWhileLoggedOut = null;
loginOverlay.style.display = "none";
appRoot.classList.add("locked");

// ========== ADD THIS NEW FLAG ==========
let suppressAutoJoinForNotification = pageOpenedFromNotification;

const setStatus = (el,msg)=> el.textContent = msg;
async function notifyCall(callId){
  // ... keep your existing code ...
}

/* ================== DIAGNOSTICS ================== */
// ... (keep all your existing diagnostic code) ...

/* ================== ERROR HANDLING ================== */
// ... (keep all your existing error handling) ...

/* ================== FIREBASE ================== */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
import {
  getFirestore, doc, collection, addDoc, setDoc, getDoc, updateDoc,
  onSnapshot, getDocs, writeBatch, query, where, limit, orderBy, serverTimestamp,
  documentId, deleteDoc, or
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

import { getMessaging, getToken, onMessage, deleteToken }
  from "https://www.gstatic.com/firebasejs/10.12.5/firebase-messaging.js";

import {
  getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut,
  setPersistence, inMemoryPersistence
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";

const app = initializeApp({
  apiKey:"AIzaSyAg6TXwgejbPAyuEPEBqW9eHaZyLV4Wq98",
  authDomain:"easosunov-webrtc.firebaseapp.com",
  projectId:"easosunov-webrtc",
  storageBucket:"easosunov-webrtc.firebasestorage.app",
  messagingSenderId:"100169991412",
  appId:"1:100169991412:web:27ef6820f9a59add6b4aa1"
});
const db = getFirestore(app);
const auth = getAuth(app);

/* ========== URL HASH / AUTOJOIN MODE ========== */
const openedFromInvite = (location.hash.length > 1);

if (openedFromInvite) {
  roomIdInput.value = location.hash.slice(1);
  setStatus(callStatus, "Room ID detected in URL.");
  logDiag("Room ID from URL hash: " + roomIdInput.value);
  
  // Log the source for debugging
  const notificationSource = localStorage.getItem('notificationSource');
  logDiag("Notification source detected: " + notificationSource);
}

/* ========== MODIFIED SCHEDULE AUTOJOIN ========== */
function scheduleAutoJoin(){
  // CRITICAL: Don't schedule auto-join if opened from notification
  if (suppressAutoJoinForNotification) {
    console.log('Suppressing auto-join: page opened from notification');
    return;
  }
  
  if (!openedFromInvite) return;
  if (suppressAutoJoin) return;
  if (autoJoinScheduled) return;

  cancelPendingAutoJoin();
  autoJoinScheduled = true;

  autoJoinTimer = setTimeout(async ()=>{
    autoJoinScheduled = false;
    autoJoinTimer = null;
    try{ await autoJoinIfNeeded(); }
    catch(e){
      setStatus(callStatus, `Auto-join failed: ${e?.message || e}`);
      showError(e);
    }
  }, 1000); // 1 second delay
}

// ========== THE REST OF YOUR CODE ==========
// ... (keep ALL the rest of your existing code EXACTLY as it is) ...
// This includes all your Firebase functions, WebRTC code, UI handlers, etc.
// Only the sections I've explicitly shown above need modification.

</script>
</body>
</html>
