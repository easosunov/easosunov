<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>2-Person Video/Sound Communicator (WebRTC)</title>

<script>
/* ========= HARD FORCE LATEST BUILD ========= */
const BUILD = "2025-12-26T00:05Z-MEMORY-CACHE-WRITE-TEST";
(function hardForceLatest(){
  try{
    const u = new URL(location.href);
    const v = u.searchParams.get("v");
    const r = u.searchParams.get("r");
    if (v !== BUILD || !r) {
      u.searchParams.set("v", BUILD);
      u.searchParams.set("r", String(Date.now()));
      location.replace(u.toString());
    }
  }catch{}
})();
</script>

<style>
  body{font-family:system-ui;margin:16px}
  h1{font-size:20px;margin:0 0 10px}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  .card{border:1px solid #ddd;border-radius:12px;padding:12px;flex:1 1 320px}
  .videos{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media (max-width: 720px){ .videos{grid-template-columns:1fr} }
  video{width:100%;background:#000;border-radius:12px;aspect-ratio:16/9}
  button{padding:10px 12px;border-radius:10px;border:1px solid #ccc;background:#f7f7f7;cursor:pointer}
  button:disabled{opacity:.6;cursor:not-allowed}
  input{padding:10px 12px;border-radius:10px;border:1px solid #ccc;width:100%}
  .status{font-size:13px;margin-top:8px}
  .small{font-size:12px;color:#555;margin-top:6px}
  code{background:#f2f2f2;padding:1px 6px;border-radius:6px}
  .badge{display:inline-block;padding:2px 8px;border:1px solid #ddd;border-radius:999px;font-size:12px;color:#333;background:#fafafa}

  #errorBox{
    display:none;margin:12px 0;padding:10px;
    border:1px solid #f3b5b5;background:#fff5f5;
    color:#7a1b1b;border-radius:12px;white-space:pre-wrap
  }
  #warnBox{
    display:none;margin:12px 0;padding:10px;
    border:2px solid #c50000;background:#fff0f0;
    color:#7a0000;border-radius:12px;white-space:pre-wrap
  }

  #loginOverlay{
    position:fixed; inset:0; z-index:9999;
    background:rgba(0,0,0,.55);
    display:flex; align-items:center; justify-content:center;
  }
  #loginCard{
    width:min(520px,calc(100% - 24px));
    background:#fff; border-radius:14px;
    padding:16px;
    box-shadow:0 10px 30px rgba(0,0,0,.35);
  }
  #loginRow{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
  #logoutBtn{float:right}
  #app.locked{filter:blur(2px);opacity:.35;pointer-events:none;user-select:none}

  #diagBox{
    display:none;
    margin-top:8px;
    max-height:320px;
    overflow:auto;
    background:#111;
    color:#0f0;
    padding:8px;
    border-radius:8px;
    font-size:12px;
    white-space:pre-wrap;
  }
  .diagActions{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
</style>
</head>

<body>
<h1>2-Person Video/Sound Communicator (WebRTC) <span id="buildBadge" class="badge"></span></h1>
<div id="warnBox"></div>
<div id="errorBox"></div>

<!-- LOGIN -->
<div id="loginOverlay">
  <div id="loginCard">
    <button id="logoutBtn" style="display:none;">Logout</button>
    <h2 style="margin:0 0 8px;font-size:18px;">Sign in required</h2>
    <div class="small">Only approved users can access this communicator.</div>

    <label class="small">Email</label>
    <input id="emailInput" type="email" placeholder="you@example.com" autocomplete="username"/>

    <label class="small">Password</label>
    <input id="passInput" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" autocomplete="current-password"/>

    <div id="loginRow">
      <button id="loginBtn">Login</button>
    </div>
    <div id="loginStatus" class="status">Please sign in.</div>
    <div class="small">Login mistakes stay here (no pink box).</div>
  </div>
</div>

<div id="app" class="locked">
  <div class="videos">
    <div class="card">
      <b>You</b>
      <video id="localVideo" autoplay muted playsinline></video>
      <div class="small">Muted so you don‚Äôt hear yourself.</div>
    </div>
    <div class="card">
      <b>Other</b>
      <video id="remoteVideo" autoplay playsinline></video>
      <div class="small">If audio doesn‚Äôt play, click the video once.</div>
    </div>
  </div>

  <div class="row" style="margin-top:12px">
    <div class="card">
      <b>Step 1</b><br/><br/>
      <button id="startBtn" disabled>Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <div class="status" id="mediaStatus">Not started.</div>
    </div>

    <div class="card">
      <b>Step 2</b><br/><br/>
      <button id="createBtn" disabled>Create Room</button>
      <button id="joinBtn" disabled>Join Room</button>
      <div class="small" style="margin-top:8px">Room ID</div>
      <input id="roomId" placeholder="Room ID"/>
      <div style="margin-top:8px">
        <button id="copyLinkBtn" disabled>Copy Invite</button>
      </div>
      <div class="status" id="callStatus">No room yet.</div>
      <div class="small">Invite format: <code>.../webrtc.html?v=BUILD&r=RANDOM#ROOM_ID</code></div>
    </div>
  </div>

  <div class="card" style="margin-top:12px">
    <button id="diagBtn">Diagnostics</button>
    <div class="diagActions">
      <button id="copyDiagBtn" disabled>Copy log</button>
      <button id="clearDiagBtn" disabled>Clear log</button>
    </div>
    <pre id="diagBox"></pre>
    <div class="small">Hidden by default. Click ‚ÄúDiagnostics‚Äù to show/hide.</div>
  </div>
</div>

<script type="module">
/* ================== BUILD / WRONG BUILD WARNING ================== */
document.getElementById("buildBadge").textContent = "BUILD " + BUILD;
const warnBox = document.getElementById("warnBox");
(function showWrongBuild(){
  try{
    const u = new URL(location.href);
    const v = u.searchParams.get("v");
    const r = u.searchParams.get("r");
    if (v !== BUILD || !r) {
      warnBox.style.display = "block";
      warnBox.textContent =
        "WRONG BUILD (should not happen after redirect)\n" +
        "Expected v=" + BUILD + " with r=<random>\n" +
        "Actual   v=" + (v ?? "(missing)") + " r=" + (r ?? "(missing)");
    }
  }catch{}
})();

/* ================== ELEMENTS ================== */
const errorBox = document.getElementById("errorBox");
const loginOverlay = document.getElementById("loginOverlay");
const loginBtn = document.getElementById("loginBtn");
const logoutBtn = document.getElementById("logoutBtn");
const loginStatus = document.getElementById("loginStatus");
const emailInput = document.getElementById("emailInput");
const passInput = document.getElementById("passInput");
const appRoot = document.getElementById("app");

const localVideo = document.getElementById("localVideo");
const remoteVideo = document.getElementById("remoteVideo");
const startBtn = document.getElementById("startBtn");
const stopBtn  = document.getElementById("stopBtn");
const createBtn= document.getElementById("createBtn");
const joinBtn  = document.getElementById("joinBtn");
const copyLinkBtn = document.getElementById("copyLinkBtn");
const roomIdInput = document.getElementById("roomId");
const mediaStatus = document.getElementById("mediaStatus");
const callStatus  = document.getElementById("callStatus");

const diagBtn = document.getElementById("diagBtn");
const diagBox = document.getElementById("diagBox");
const copyDiagBtn = document.getElementById("copyDiagBtn");
const clearDiagBtn = document.getElementById("clearDiagBtn");
const setStatus = (el,msg)=> el.textContent = msg;

/* ================== DIAGNOSTICS ================== */
let diagVisible = false;
const diagLog = [];
function logDiag(msg){
  const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
  diagLog.push(line);
  console.log(line);
  if (diagVisible) {
    diagBox.textContent = diagLog.join("\n");
    diagBox.scrollTop = diagBox.scrollHeight;
  }
  copyDiagBtn.disabled = diagLog.length === 0;
  clearDiagBtn.disabled = diagLog.length === 0;
}
logDiag("BOOT: " + BUILD);
logDiag("URL: " + location.href);
logDiag("navigator.onLine=" + navigator.onLine);

window.addEventListener("online", ()=>logDiag("Browser ONLINE event"));
window.addEventListener("offline", ()=>logDiag("Browser OFFLINE event"));

diagBtn.onclick = () => {
  diagVisible = !diagVisible;
  diagBox.style.display = diagVisible ? "block" : "none";
  diagBtn.textContent = diagVisible ? "Hide diagnostics" : "Diagnostics";
  if (diagVisible) {
    diagBox.textContent = diagLog.join("\n");
    diagBox.scrollTop = diagBox.scrollHeight;
  }
};
clearDiagBtn.onclick = () => {
  diagLog.length = 0;
  if (diagVisible) diagBox.textContent = "";
  copyDiagBtn.disabled = true;
  clearDiagBtn.disabled = true;
  logDiag("Diagnostics cleared.");
};
copyDiagBtn.onclick = async () => {
  const text = diagLog.join("\n");
  if (!text) return;
  try{ await navigator.clipboard.writeText(text); logDiag("Copied diagnostics to clipboard."); }
  catch{ window.prompt("Copy diagnostics:", text); }
};

/* ================== ERROR HANDLING ================== */
function showError(e){
  errorBox.style.display = "block";
  errorBox.textContent = String(e?.stack || e?.message || e);
  logDiag("ERROR: " + String(e?.code || e?.message || e));
}
function hideErrorBox(){ errorBox.style.display="none"; errorBox.textContent=""; }
window.addEventListener("error", (e)=> showError(e.error || e.message || e));
window.addEventListener("unhandledrejection", (e)=> showError(e.reason || e));

/* ================== TIMEOUT WRAPPER ================== */
function withTimeout(promise, ms, label){
  let t;
  const timeout = new Promise((_, rej)=>{
    t = setTimeout(()=> rej(new Error(`TIMEOUT after ${ms}ms: ${label}`)), ms);
  });
  return Promise.race([
    promise.finally(()=>clearTimeout(t)),
    timeout
  ]);
}

/* ================== FIREBASE (MEMORY CACHE + LONG POLLING) ================== */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
import {
  initializeFirestore, memoryLocalCache,
  doc, collection, addDoc, setDoc, getDoc, updateDoc,
  onSnapshot, getDocs, writeBatch,
  getDocFromServer, enableNetwork
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";
import {
  getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";

const fbApp = initializeApp({
  apiKey:"AIzaSyAg6TXwgejbPAyuEPEBqW9eHaZyLV4Wq98",
  authDomain:"easosunov-webrtc.firebaseapp.com",
  projectId:"easosunov-webrtc",
  storageBucket:"easosunov-webrtc.firebasestorage.app",
  messagingSenderId:"100169991412",
  appId:"1:100169991412:web:27ef6820f9a59add6b4aa1"
});

const db = initializeFirestore(fbApp, {
  localCache: memoryLocalCache(),            // ‚úÖ no IndexedDB
  experimentalForceLongPolling: true,
  useFetchStreams: false
});
logDiag("Firestore init: memoryLocalCache + experimentalForceLongPolling=true");

const auth = getAuth(fbApp);

/* ================== AUTH ================== */
let isAuthed = false;

function requireAuthOrPrompt(){
  if (isAuthed) return true;
  loginOverlay.style.display = "flex";
  appRoot.classList.add("locked");
  loginStatus.textContent = "Please sign in first.";
  return false;
}

loginBtn.onclick = async () => {
  hideErrorBox();
  loginStatus.textContent = "Signing in‚Ä¶";
  try{
    await signInWithEmailAndPassword(auth, emailInput.value.trim(), passInput.value);
  }catch(e){
    loginStatus.textContent = "Login failed.";
    logDiag("Login failed: " + (e?.code || e?.message || e));
  }
};
logoutBtn.onclick = async () => { try { await signOut(auth); } catch(e){ showError(e); } };

/* ================== INVITE MODE ================== */
const openedFromInvite = (location.hash.length > 1);
if (openedFromInvite) {
  roomIdInput.value = location.hash.slice(1);
  setStatus(callStatus, "Room ID detected in URL.");
  logDiag("Room ID from URL hash: " + roomIdInput.value);
}

/* ================== WEBRTC ================== */
let localStream = null;
let pc = null;
const rtcConfig = { iceServers:[{ urls:"stun:stun.l.google.com:19302" }] };

function closePeer(){
  if(pc){
    pc.onicecandidate=null; pc.ontrack=null;
    pc.onconnectionstatechange=null; pc.oniceconnectionstatechange=null;
    try{ pc.close(); }catch{}
    pc=null;
  }
  remoteVideo.srcObject = null;
}

function ensurePeer(){
  closePeer();
  pc = new RTCPeerConnection(rtcConfig);
  logDiag("Created RTCPeerConnection");

  const rs = new MediaStream();
  remoteVideo.srcObject = rs;

  pc.ontrack = (e)=>{
    e.streams[0].getTracks().forEach(t=>rs.addTrack(t));
    remoteVideo.muted = false;
    remoteVideo.play().catch(()=>{});
    logDiag("ontrack: " + e.streams[0].getTracks().map(t=>t.kind).join(","));
  };

  pc.onconnectionstatechange = ()=> pc && logDiag("pc.connectionState=" + pc.connectionState);
  pc.oniceconnectionstatechange = ()=> pc && logDiag("pc.iceConnectionState=" + pc.iceConnectionState);

  if(!localStream) throw new Error("Local media not started.");
  localStream.getTracks().forEach(t=>pc.addTrack(t, localStream));
}

/* ================== FIRESTORE HELPERS ================== */
async function clearSubBestEffort(col){
  try{
    const s = await withTimeout(getDocs(col), 6000, "getDocs(" + col.path + ")");
    if(s.empty) return;
    const b = writeBatch(db);
    s.forEach(d=>b.delete(d.ref));
    await withTimeout(b.commit(), 6000, "batch.commit(" + col.path + ")");
    logDiag(`Cleared ${col.path} docs=${s.size}`);
  }catch(e){
    logDiag(`WARN: clearSub blocked for ${col.path}: ` + (e?.code || e?.message || e));
  }
}

/* ================== UI HELPERS ================== */
function refreshCopyInviteState(){
  const hasRoomId = !!roomIdInput.value.trim();
  copyLinkBtn.disabled = !(isAuthed && hasRoomId);
}
roomIdInput.addEventListener("input", refreshCopyInviteState);

/* ================== MEDIA ================== */
let startingPromise = null;
async function startMedia(){
  if(!requireAuthOrPrompt()) return;
  if(localStream) return;
  if(startingPromise) return startingPromise;

  startingPromise = (async()=>{
    hideErrorBox();
    setStatus(mediaStatus,"Requesting camera/mic‚Ä¶");
    logDiag("Requesting getUserMedia‚Ä¶");

    localStream = await navigator.mediaDevices.getUserMedia({video:true,audio:true});
    localVideo.srcObject = localStream;

    setStatus(mediaStatus,"Camera/mic started.");
    logDiag("Camera/mic started.");

    localVideo.onloadedmetadata = async ()=>{
      try{ await localVideo.play(); }catch{}
      logDiag("Local video playing.");
    };

    startBtn.disabled = true;
    stopBtn.disabled  = false;
    createBtn.disabled = false;
    joinBtn.disabled   = false;
  })();

  try{ await startingPromise; }
  finally{ startingPromise = null; }
}

/* ================== LISTENERS ================== */
let unsubRoomA=null, unsubCalleeA=null;
let unsubRoomB=null, unsubCallerB=null;

function stopListeners(){
  if(unsubRoomA){ unsubRoomA(); unsubRoomA=null; }
  if(unsubCalleeA){ unsubCalleeA(); unsubCalleeA=null; }
  if(unsubRoomB){ unsubRoomB(); unsubRoomB=null; }
  if(unsubCallerB){ unsubCallerB(); unsubCallerB=null; }
}

/* ================== STOP ================== */
function stopAll(){
  stopListeners();
  closePeer();

  if(localStream){
    localStream.getTracks().forEach(t=>t.stop());
    localStream=null;
  }
  localVideo.srcObject=null;

  startBtn.disabled = !isAuthed;
  stopBtn.disabled = true;
  createBtn.disabled = true;
  joinBtn.disabled = true;

  setStatus(mediaStatus,"Not started.");
  setStatus(callStatus,"No room yet.");
  refreshCopyInviteState();
}
stopBtn.onclick = ()=> stopAll();

/* ================== WRITE TEST (AUTO) ==================
   This is the crucial probe. If THIS still times out, you have a network block
   or an environment that cannot reach Firestore write endpoints.
*/
async function runWriteTest(){
  if(!auth.currentUser) return;
  const uid = auth.currentUser.uid;
  const pingRef = doc(db, "diag", "ping_" + uid);
  try{
    logDiag("WRITE TEST: setDoc(diag/ping_<uid>)...");
    await withTimeout(setDoc(pingRef, { t: Date.now(), build: BUILD }, { merge:true }), 8000, "writeTest:setDoc");
    logDiag("WRITE TEST: setDoc resolved.");
  }catch(e){
    logDiag("WRITE TEST FAILED: " + (e?.message || e));
    warnBox.style.display = "block";
    warnBox.textContent =
      "üö´ Firestore WRITES are failing/hanging in this browser/network.\n\n" +
      "We tried to write diag/ping_<uid> and it timed out.\n\n" +
      "Common causes:\n" +
      "‚Ä¢ Safari private mode / blocked storage (IndexedDB)\n" +
      "‚Ä¢ VPN / firewall / adblock blocking Google Firestore endpoints\n" +
      "‚Ä¢ Corporate network restrictions\n\n" +
      "Try: different browser (Chrome), disable VPN/adblock, or different network/hotspot.\n\n" +
      "Details: " + (e?.message || e);
    return;
  }

  try{
    logDiag("WRITE TEST: getDocFromServer(diag/ping_<uid>)...");
    const s = await withTimeout(getDocFromServer(pingRef), 8000, "writeTest:getDocFromServer");
    logDiag("WRITE TEST: server verify exists=" + s.exists());
    if(!s.exists()){
      warnBox.style.display = "block";
      warnBox.textContent =
        "‚ö†Ô∏è Firestore write resolved locally but server verify says doc does NOT exist.\n" +
        "This indicates the client cannot reach Firestore servers reliably.";
    }
  }catch(e){
    logDiag("WRITE TEST server verify FAILED: " + (e?.message || e));
    warnBox.style.display = "block";
    warnBox.textContent =
      "‚ö†Ô∏è Firestore server verify failed.\n\n" +
      "Writes may be queued locally, but server is unreachable.\n\n" +
      "Try: disable VPN/adblock or use another network.\n\n" +
      "Details: " + (e?.message || e);
  }
}

/* ================== Guest nudge (must not create) ================== */
async function nudgeHostUpdateOnly(roomRef){
  try{
    await withTimeout(updateDoc(roomRef, { joinRequest: Date.now() }), 6000, "updateDoc(joinRequest)");
    logDiag("Nudged host (joinRequest via updateDoc).");
    return true;
  }catch(e){
    logDiag("Nudge skipped (room not created yet): " + (e?.message || e));
    return false;
  }
}

/* ================== HOST ================== */
let lastSeenJoinRequestA = 0;
let createAttemptA = 0;

async function createRoom(){
  if(!requireAuthOrPrompt()) return;

  stopListeners();
  await startMedia();

  const myAttempt = ++createAttemptA;

  let roomRef;
  const existing = roomIdInput.value.trim();
  if(existing) roomRef = doc(db,"rooms", existing);
  else roomRef = doc(collection(db,"rooms"));

  roomIdInput.value = roomRef.id;
  location.hash = roomRef.id;
  refreshCopyInviteState();

  logDiag("HOST createRoom: roomId=" + roomRef.id);

  const caller = collection(roomRef,"callerCandidates");
  const callee = collection(roomRef,"calleeCandidates");

  try{
    await withTimeout(enableNetwork(db), 6000, "enableNetwork()");
    logDiag("enableNetwork() OK");
  }catch(e){
    logDiag("WARN: enableNetwork failed: " + (e?.message || e));
  }

  // EARLY room doc write + server verify
  try{
    logDiag("HOST writing early room doc...");
    await withTimeout(setDoc(roomRef, {
      state: "creating",
      build: BUILD,
      updatedAt: Date.now(),
      hostUid: auth.currentUser?.uid || null
    }, { merge:true }), 12000, "setDoc(room early)");

    logDiag("HOST early setDoc resolved.");

    logDiag("HOST verifying room exists on SERVER...");
    const s = await withTimeout(getDocFromServer(roomRef), 12000, "getDocFromServer(room)");
    logDiag("HOST server verify: exists=" + s.exists());
  }catch(e){
    logDiag("HOST FAILED early room write/verify: " + (e?.message || e));
    showError(e);
    return;
  }

  // session
  let session = 1;
  try{
    const snap = await withTimeout(getDoc(roomRef), 6000, "getDoc(room)");
    const prev = snap.exists() ? (snap.data().session || 0) : 0;
    session = Number(prev) + 1;
    logDiag("HOST computed session=" + session);
  }catch(e){
    logDiag("WARN: HOST getDoc(session) failed: " + (e?.message || e));
  }

  await clearSubBestEffort(caller);
  await clearSubBestEffort(callee);

  try{ ensurePeer(); } catch(e){ showError(e); return; }

  pc.onicecandidate = (e)=>{
    if(e.candidate){
      addDoc(caller, { session, ...e.candidate.toJSON() }).catch((err)=>{
        logDiag("WARN: addDoc(callerCandidate) failed: " + (err?.message || err));
      });
    }
  };

  try{
    logDiag("HOST creating offer‚Ä¶");
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    logDiag("HOST setLocalDescription(offer) OK.");

    logDiag("HOST writing offer+session...");
    await withTimeout(setDoc(roomRef, {
      state: "offered",
      session,
      offer: { type: offer.type, sdp: offer.sdp },
      answer: null,
      updatedAt: Date.now()
    }, { merge:true }), 12000, "setDoc(room offer)");

    logDiag("HOST wrote offer+session to room doc. session=" + session);
    setStatus(callStatus, `Room active (session ${session}). Send invite to B.`);
  }catch(e){
    logDiag("HOST FAILED writing offer/session: " + (e?.message || e));
    showError(e);
    return;
  }

  unsubRoomA = onSnapshot(
    roomRef,
    async (s)=>{
      if(myAttempt !== createAttemptA) return;
      const d = s.data();
      if(!d) return;

      if(d.joinRequest && d.joinRequest > lastSeenJoinRequestA){
        lastSeenJoinRequestA = d.joinRequest;
        setStatus(callStatus, "Join request received ‚Äî restarting session‚Ä¶");
        logDiag("HOST saw joinRequest => restarting offer/session.");
        setTimeout(()=>createRoom().catch(()=>{}), 150);
        return;
      }

      if(d.answer && d.session === session && pc && pc.signalingState==="have-local-offer" && !pc.currentRemoteDescription){
        try{
          await pc.setRemoteDescription(d.answer);
          setStatus(callStatus, `Connected (session ${session}).`);
          logDiag("HOST applied answer.");
        }catch(e){
          logDiag("HOST apply answer failed: " + (e?.message || e));
        }
      }
    },
    (err)=>{ logDiag("HOST SNAPSHOT ERROR(room): " + (err?.message || err)); showError(err); }
  );

  unsubCalleeA = onSnapshot(
    callee,
    (ss)=>{
      ss.docChanges().forEach(ch=>{
        if(ch.type!=="added" || !pc) return;
        const c = ch.doc.data();
        if(c.session !== session) return;
        try{ pc.addIceCandidate(c); }catch{}
      });
    },
    (err)=>{ logDiag("HOST SNAPSHOT ERROR(calleeCandidates): " + (err?.message || err)); showError(err); }
  );
}

/* ================== GUEST ================== */
let joinAttemptB = 0;
let joinInProgress = false;
let lastAnsweredSessionB = null;

async function joinRoom(){
  if(!requireAuthOrPrompt()) return;

  const roomId = roomIdInput.value.trim();
  if(!roomId) throw new Error("Room ID is empty.");
  const roomRef = doc(db,"rooms", roomId);

  if(joinInProgress){
    logDiag("Join clicked while joining => nudge host (updateDoc only)");
    const ok = await nudgeHostUpdateOnly(roomRef);
    setStatus(callStatus, ok ? "Nudged host. Still waiting‚Ä¶" : "Host has not created the room yet.");
    return;
  }

  joinInProgress = true;
  const myAttempt = ++joinAttemptB;

  await startMedia();
  stopListeners();
  location.hash = roomId;

  setStatus(callStatus, "Waiting for host / offer‚Ä¶");
  logDiag("GUEST joinRoom: roomId=" + roomId);
  logDiag("GUEST installing onSnapshot(roomRef)‚Ä¶");

  unsubRoomB = onSnapshot(
    roomRef,
    async (snap)=>{
      if(myAttempt !== joinAttemptB) return;

      logDiag("GUEST room snapshot: exists=" + snap.exists());
      if(!snap.exists()){
        setStatus(callStatus, "Waiting for host to create the room‚Ä¶");
        return;
      }

      const d = snap.data() || {};
      logDiag(`GUEST room data: state=${d.state ?? "none"} hasOffer=${!!d.offer} session=${d.session ?? "none"}`);

      if(!d.offer || !d.session){
        setStatus(callStatus, "Room exists. Waiting for host offer/session‚Ä¶");
        return;
      }

      if(lastAnsweredSessionB === d.session) return;
      lastAnsweredSessionB = d.session;

      try{
        ensurePeer();
        const caller = collection(roomRef,"callerCandidates");
        const callee = collection(roomRef,"calleeCandidates");

        await clearSubBestEffort(callee);
        if(myAttempt !== joinAttemptB) return;

        pc.onicecandidate = (e)=>{
          if(e.candidate){
            addDoc(callee, { session: d.session, ...e.candidate.toJSON() }).catch((err)=>{
              logDiag("WARN: addDoc(calleeCandidate) failed: " + (err?.message || err));
            });
          }
        };

        await pc.setRemoteDescription(d.offer);
        const ans = await pc.createAnswer();
        await pc.setLocalDescription(ans);

        await withTimeout(updateDoc(roomRef, { answer: ans, session: d.session, answeredAt: Date.now(), state:"answered" }), 12000, "updateDoc(answer)");

        setStatus(callStatus, `Joined room. Connecting‚Ä¶ (session ${d.session})`);
        logDiag("GUEST wrote answer.");

        if(unsubCallerB){ unsubCallerB(); unsubCallerB=null; }
        unsubCallerB = onSnapshot(
          caller,
          (ss)=>{
            ss.docChanges().forEach(ch=>{
              if(ch.type!=="added" || !pc) return;
              const c = ch.doc.data();
              if(c.session !== d.session) return;
              try{ pc.addIceCandidate(c); }catch{}
            });
          },
          (err)=>{ logDiag("GUEST SNAPSHOT ERROR(callerCandidates): " + (err?.message || err)); showError(err); }
        );

        pc.onconnectionstatechange = ()=>{
          if(myAttempt !== joinAttemptB || !pc) return;
          setStatus(callStatus, `B: ${pc.connectionState} (session ${d.session})`);
          if(pc.connectionState === "connected"){
            joinInProgress = false;
            logDiag("GUEST connected => joinInProgress=false");
          }
        };

      }catch(e){
        lastAnsweredSessionB = null;
        logDiag("GUEST join error: " + (e?.message || e));
        setStatus(callStatus, "Join error ‚Äî waiting / retrying‚Ä¶");
      }
    },
    (err)=>{
      logDiag("GUEST SNAPSHOT ERROR(room): " + (err?.message || err));
      setStatus(callStatus, "Firestore listener error (see diagnostics).");
      showError(err);
      joinInProgress = false;
    }
  );

  nudgeHostUpdateOnly(roomRef).catch(()=>{});
}

/* ================== COPY INVITE (ALWAYS FRESH) ================== */
async function copyTextRobust(text){
  if(navigator.clipboard && window.isSecureContext){
    try{ await navigator.clipboard.writeText(text); return true; }catch{}
  }
  window.prompt("Copy this invite link:", text);
  return false;
}
copyLinkBtn.onclick = async ()=>{
  const roomId = roomIdInput.value.trim();
  if(!roomId) return;
  const invite = `${location.origin}${location.pathname}?v=${encodeURIComponent(BUILD)}&r=${Date.now()}#${roomId}`;
  const ok = await copyTextRobust(invite);
  setStatus(callStatus, ok ? "Invite copied (fresh cache-bust)." : "Clipboard blocked ‚Äî link shown for manual copy.");
  logDiag("Invite copied: v=" + BUILD + " r=<now>");
};

/* ================== BUTTONS ================== */
startBtn.onclick = ()=> startMedia().catch(showError);
createBtn.onclick = ()=> createRoom().catch(showError);
joinBtn.onclick   = ()=> joinRoom().catch(showError);

/* ================== AUTH STATE ================== */
onAuthStateChanged(auth, (user)=>{
  isAuthed = !!user;
  logDiag(isAuthed ? "Auth: signed in" : "Auth: signed out");

  if(isAuthed){
    loginOverlay.style.display = "none";
    appRoot.classList.remove("locked");
    logoutBtn.style.display = "inline-block";
    loginStatus.textContent = "Signed in.";

    startBtn.disabled = false;
    stopBtn.disabled = true;
    createBtn.disabled = true;
    joinBtn.disabled = true;

    setStatus(mediaStatus, "Ready. Click Start.");
    refreshCopyInviteState();

    // üî• auto write test right after auth
    setTimeout(()=>runWriteTest().catch(()=>{}), 0);

    if(openedFromInvite){
      setStatus(callStatus, "Invite detected. Click Start (or Join) to connect.");
      logDiag("Invite mode: waiting for user gesture to start media.");
      window.addEventListener("click", async ()=>{
        try{ await startMedia(); await joinRoom(); }
        catch(e){ logDiag("Auto sequence failed: " + (e?.message || e)); }
      }, { once:true });
    }
  }else{
    loginOverlay.style.display = "flex";
    appRoot.classList.add("locked");
    logoutBtn.style.display = "none";
    stopAll();
  }
});

window.addEventListener("beforeunload", ()=>{ try{ closePeer(); }catch{} });
</script>
</body>
</html>
